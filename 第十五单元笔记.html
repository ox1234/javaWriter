<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.12.3 (455521)"/><meta name="author" content="923435274@qq.com"/><meta name="created" content="2017-09-08 14:31:14 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-09-16 02:48:26 +0000"/><title>第十五单元笔记</title></head><body>


<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程-定时器和线程组</h1>
  </td></tr>
</table>
<div>在JDK的java.util包中提供了Timer类，可与你定时执行特定的任务</div><div>TimerTask类表示定时器执行的某一项任务</div><div><hr/>ThreadGroup类表示线程组，可以堆一组线程进行集中管理</div><div>用户在创建线程对象时，可以通过构造器指定其所属的线程组</div><div>如果A线程创建了B线程，如果没有设置B线程的分组，那么B线程加入到A线程的线程组</div><div>一旦线程加入某个线程组，该线程就一直存在于法线程组中知道线程死亡，不能在中途修改线程的分组</div><div><hr/>当java程序运行时，JVM会创建名为main的线程组，在默认情况下，所有的线程都在该线程组下</div><div><hr/>线程相关的知识点：</div><div><span>    1、线程安全的集合对象</span><br/></div><div><span><span>    2、ThreadLocal：本地线程变量（ThreadLocal模式）</span><br/></span></div><div><span><span><span>    3、线程池，java8对线程池新增的功能</span><br/></span></span></div><div><span><span><span><span>    4、java5新增的线程并发操作</span><br/></span></span></span></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程操作-线程的礼让</h1>
  </td></tr>
</table>
<div>线程礼让：</div><div>yield方法：表示当前线程对象提示调度器自己愿意让出cpu资源，但是调度器可以自由的忽略该提示</div><div>调用该方法之后，线程对象进入就绪状态，所以完全有可能：某个线程调用了yield()之后，线程调度器又把他调度出来重新执行</div><div>从java7提供的文档上可以清楚的看出，开发中很少会使用到该方法，该方法主要用于调适或测试，它可能有助于因多线程竞争条件下的错误重现现象</div><div><hr/>sleep方法和yield方法的区别：</div><div>1、都能时当前处于运行状态的线程放弃cpu，把运行的机会给其他线程</div><div>2、sleep方法会给其他线程运行机会，但是不考虑其他线程的优先级，yield方法只会给相同优先级或者更高优先级的线程运行的机会</div><div>3、调用sleep方法后，线程进入计时等待状态，调用yield方法后，线程进入就绪状态</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程的操作-线程的优先级</h1>
  </td></tr>
</table>
<div>每个线程都有优先级，优先级的高低只和线程活的执行机会的次数多少有关，并非线程优先级越高的就一定先执行，那个线程线运行取决于cpu的调度</div><div><hr/>int getPriority():返回线程的优先级</div><div>void setPriority(int newPriority)：设置线程优先级</div><div><hr/>每个线程都有默认优先级，主线程默认优先级为5，如果A线程创建了B线程，那么B线程和A线程具有相同的优先级</div><div>注意：不同的操作系统支持的线程优先级不同的，建议先使用上述三个优先级，不要自定义</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程的操作-联合线程／后台线程</h1>
  </td></tr>
</table>
<div>联合线程：</div><div>线程的join方法表示一个线程等待另一个线程完成之后才执行，join方法被调用后，线程对象处于阻塞状态</div><div>也有人把这种方法称之为联合线程，就是说把当前线程和当前线程所在的线程联合为一个线程</div><div><hr/>后台线程：在后台运行的线程，目的是为了为其他线程提供服务，也称为“守护线程”，JVM的垃圾回收线程就是典型的后台线程</div><div>特点：若所有前台线程都死亡，后台线程自动死亡，前台线程没有结束，后台线程是不会结束的</div><div>前台线程创建的线程默认是前台线程，可以通过setDaenon（true）方法设置为后台线程，并且当且仅当后台线程创建新线程时。新线程是后台线程</div><div><hr/><span style="font: 11.0px Monaco; color: #931a68;">package</span><span style="font: 11.0px Monaco;"> com._520it_day01_04_thread_method;</span></div><div><br/></div><div><span style="font: 11.0px Monaco; color: #931a68;">class</span><span style="font: 11.0px Monaco;"> DaemonThread </span><span style="font: 11.0px Monaco; color: #931a68;">extends</span><span style="font: 11.0px Monaco;"> Thread{</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">public</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">void</span><span style="font: 11.0px Monaco;"> run(){</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">for</span><span style="font: 11.0px Monaco;">(</span><span style="font: 11.0px Monaco; color: #931a68;">int</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">=0;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">&lt;500;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">++){</span></div><div><span style="font: 11.0px Monaco;">System.</span><span style="font: 11.0px Monaco; color: #0326cc;">out</span><span style="font: 11.0px Monaco;">.println(</span><span style="font: 11.0px Monaco; color: #931a68;">super</span><span style="font: 11.0px Monaco;">.getName()+</span><span style="font: 11.0px Monaco; color: #3933ff;">"-"</span><span style="font: 11.0px Monaco;">+</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">);</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco; color: #4e9072;">//后台线程</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">public</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">class</span><span style="font: 11.0px Monaco;"> DaemonDemo {</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">public</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">static</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">void</span><span style="font: 11.0px Monaco;"> main(String[] </span><span style="font: 11.0px Monaco; color: #7e504f;">args</span><span style="font: 11.0px Monaco;">) {</span></div><div><span style="font: 11.0px Monaco; color: #4e9072;">//主线程不是后台线程</span></div><div><span style="font: 11.0px Monaco; color: #4e9072;">//System.out.println(Thread.currentThread().isDaemon());</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">for</span><span style="font: 11.0px Monaco;">(</span><span style="font: 11.0px Monaco; color: #931a68;">int</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">=0;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">&lt;50;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">++){</span></div><div><span style="font: 11.0px Monaco;">System.</span><span style="font: 11.0px Monaco; color: #0326cc;">out</span><span style="font: 11.0px Monaco;">.println(</span><span style="font: 11.0px Monaco; color: #3933ff;">"mian"</span><span style="font: 11.0px Monaco;">+</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">);</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">if</span><span style="font: 11.0px Monaco;">(</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">==10){</span></div><div><span style="font: 11.0px Monaco;">DaemonThread </span><span style="font: 11.0px Monaco; color: #7e504f;">t</span><span style="font: 11.0px Monaco;">=</span><span style="font: 11.0px Monaco; color: #931a68;">new</span><span style="font: 11.0px Monaco;"> DaemonThread();</span></div><div><span style="font: 11.0px Monaco; color: #7e504f;">t</span><span style="font: 11.0px Monaco;">.setDaemon(</span><span style="font: 11.0px Monaco; color: #931a68;">true</span><span style="font: 11.0px Monaco;">);</span></div><div><span style="font: 11.0px Monaco; color: #7e504f;">t</span><span style="font: 11.0px Monaco;">.start();</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><br/><span style="font: 11.0px Monaco;">}</span></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程的操作-线程睡眠</h1>
  </td></tr>
</table>
<div>线程休眠：让执行的线程暂停一段时间，进入计时等待状态</div><div>方法：static void sleep(long millis)</div><div><br/></div><div>调用sleep之后，当前线程放弃cpu，在指定时间段之内，sleep所在线程不会获得执行的机会，<font color="#ff2600">此状态下的线程不会释放同步锁／同步监听器</font></div><div>该方法更多的用于模拟网络延迟，让多线程并发访问同一个资源的错误效果更明显</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程-分析线程的生命周期中的各个状态</h1>
  </td></tr>
</table>
<div>1、新建状态（new）：使用new创建一个线程对象，仅仅在堆中分配内存空间，新建状态在start()方法之前</div><div>    新建状态下，线程压根就没有启动，仅仅只是存在一个线程对象而已</div><div>    Thread t=new Thread();//此时t就属于新建状态</div><div><br/></div><div>    当新建状态下的线程对象调用start方法，此时从新建状态进入可运行状态</div><div>    线程对象的start方法只能调用一次，否则报错</div><div>2、可运行状态（runnable）：分为两种状态，ready和running，分别表示就绪状态和运行状态</div><div>            就绪状态：线程对象调用start方法之后，等待JVM的调度（此时该线程并没有运行）</div><div>            运行状态：线程对象获得JVM的调度，如果存在多个cpu，那么允许多个线程并行运行</div><div>3、阻塞状态（blocked）：正在运行的程序因为某些原因放弃cpu，暂时停止运行，就会进入阻塞状态</div><div>    此时JVM不会给线程分配cpu，知道线程重新进入就绪状态，才有机会转到运行状态</div><div><span>    阻塞状态只能先进入就绪状态，不能直接进入运行状态</span><br/></div><div>    阻塞状态的两种情况：</div><div>                1、当A线程处于运行过程时，试图获取同步锁时，却被B线程获取，此时JVM把当前A线程存到对象的锁池中，A线程进入阻塞状态</div><div>                2、当线程处于运行过程时，发出了IO请求时，此时进入阻塞状态</div><div>4、等待状态（waiting）：</div><div>                1、当前线程处于运行过程时，调用了wait()方法，此时JVM吧当前线程存在对象等待池中</div><div>                2、当前线程执行了sleep()方法</div><div>5、计时等待状态（timed waiting）：</div><div><span>    <span>    <span>    <span>    1、当线程处于运行状态过程时，调用了wait(long time)方法，此时JVM吧当前线程存在对象等待池中</span></span></span></span><br/></div><div><span><span><span><span><span>    <span>    <span>    <span>    2、当前线程执行了sleep(long time)方法</span></span></span></span><br/></span></span></span></span></div><div>6、终止状态（terminated）：通常称为死亡状态，表示线程终止</div><div><span>    <span>    <span>    <span>    1、正常执行完run方法而退出（正常死亡）</span></span></span></span><br/></div><div><span><span><span><span><span>    <span>    <span>    <span>    2、遇到异常而退出（出现异常之后，程序就会中断）（意外死亡）</span></span></span></span><br/></span></span></span></span></div><div><span><span><span><span><span><span><span><span><hr/>线程一旦终止，就不能再启动线程了，否则会报错</span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><br/></span></span></span></span></span></span></span></span></div><div>在Thread类中过世的方法是因为线程安全问题被弃用了</div><div>void suspend()：暂停当前线程</div><div>void resume()：恢复当前线程</div><div>void stop()：结束当前线程</div><div><div><span style="font: 11.0px Monaco; color: #931a68;">package</span><span style="font: 11.0px Monaco;"> com._520it_day03._01_thread_state;</span></div><div><br/></div><div><span style="font: 11.0px Monaco; color: #931a68;">import</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; text-decoration: underline;">java.io.IOException</span><span style="font: 11.0px Monaco;">;</span></div><div><br/></div><div><span style="font: 11.0px Monaco; color: #931a68;">class</span><span style="font: 11.0px Monaco;"> Other </span><span style="font: 11.0px Monaco; color: #931a68;">extends</span><span style="font: 11.0px Monaco;"> Thread{</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">public</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">void</span><span style="font: 11.0px Monaco;"> run(){</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">for</span><span style="font: 11.0px Monaco;">(</span><span style="font: 11.0px Monaco; color: #931a68;">int</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">=0;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">&lt;10;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">++){</span></div><div><span style="font: 11.0px Monaco;">System.</span><span style="font: 11.0px Monaco; color: #0326cc;">out</span><span style="font: 11.0px Monaco;">.println(</span><span style="font: 11.0px Monaco; color: #3933ff;">"Other-"</span><span style="font: 11.0px Monaco;">+</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">);</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">public</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">class</span><span style="font: 11.0px Monaco;"> Runnable {</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">public</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">static</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #931a68;">void</span><span style="font: 11.0px Monaco;"> main(String[] </span><span style="font: 11.0px Monaco; color: #7e504f;">args</span><span style="font: 11.0px Monaco;">) {</span></div><div><span style="font: 11.0px Monaco;">Other </span><span style="font: 11.0px Monaco; color: #7e504f;">other</span><span style="font: 11.0px Monaco;">=</span><span style="font: 11.0px Monaco; color: #931a68;">new</span><span style="font: 11.0px Monaco;"> Other();</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">for</span><span style="font: 11.0px Monaco;">(</span><span style="font: 11.0px Monaco; color: #931a68;">int</span><span style="font: 11.0px Monaco;"/><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">=0;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">&lt;50;</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">++){</span></div><div><span style="font: 11.0px Monaco;">System.</span><span style="font: 11.0px Monaco; color: #0326cc;">out</span><span style="font: 11.0px Monaco;">.println(</span><span style="font: 11.0px Monaco; color: #3933ff;">"main:"</span><span style="font: 11.0px Monaco;">+</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">);</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">if</span><span style="font: 11.0px Monaco;">(</span><span style="font: 11.0px Monaco; color: #7e504f;">i</span><span style="font: 11.0px Monaco;">==10){</span></div><div><span style="font: 11.0px Monaco; color: #7e504f;">other</span><span style="font: 11.0px Monaco;">.start();</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco; color: #931a68;">if</span><span style="font: 11.0px Monaco;">(!</span><span style="font: 11.0px Monaco; color: #7e504f;">other</span><span style="font: 11.0px Monaco;">.isAlive()==</span><span style="font: 11.0px Monaco; color: #931a68;">true</span><span style="font: 11.0px Monaco;">){</span></div><div><span style="font: 11.0px Monaco; color: #7e504f;">other</span><span style="font: 11.0px Monaco;">.start();</span><span style="font: 11.0px Monaco; color: #4e9072;">//再次启动当前线程</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco; color: #4e9072;">//Other other=new Other();//此时other为新建状态</span></div><div><span style="font: 11.0px Monaco; color: #4e9072;">//other.start();//调用start之后other对象属于可运行状态</span></div><div><span style="font: 11.0px Monaco;">}</span></div><div><span style="font: 11.0px Monaco;">}</span><hr/><br/></div></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程的生命周期和状态概述</h1>
  </td></tr>
</table>
<div>生命周期：一个事物从出生的那一刻开始到最终死亡中间的整个过程</div><div>在事物的漫长的生命周期过程中，总会经历不同的状态（婴儿状态，青少年状态，中年状态，老年状态。。。）</div><div>线程也是由生命周期的，也是存在不同的状态，状态相互之间的转换。<img src="%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/timg.jpeg" height="340" width="681"/></div><div><img src="%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/timg_1.jpeg" height="586" width="910"/></div><div>有人又把阻塞状态，等待状态，计时状态合称为阻塞状态</div><div><hr/>线程对象的状态存放在Thread类的内部类（State）中</div><div><br/></div><div>注意：Thread.State类其实是一个枚举类</div><div><span>    因为线程对象的对象是固定的，只有6种，此时使用枚举来表示是最恰当的</span><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程通讯-死锁概述</h1>
  </td></tr>
</table>
<div>多线程通信的时候，很容易形成死锁，死锁无法解决，只能避免</div><div>当A线程等待由B线程持有的锁，而B线程正在等待A线程持有的锁时，发生死锁现象，JVM不检测也不试图避免这种情况，所以程序员必须保证不导致死锁</div><div>避免死锁法则：当多个线程都要访问共享的资源A，B，C时，保证每一个线程都按照相同的顺序去访问他们，比如都先访问A，接着B，然后C</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程通信-使用Lock和Condition接口</h1>
  </td></tr>
</table>
<div>wait和notify方法：只能被同步监听对象来调用，否则报错</div><div>那么问题来了，Lock机制根本就没有同步锁了，也就没有自动获取锁的自动释放锁的概念</div><div>因为没有同步锁，所以Lock机制不能调用wait和notify方法</div><div>解决方案：java5中提供了lock机制的同时提供了处理Lock机制的通信控制的Condition接口</div><div><hr/><div>从java5开始，可以：</div></div><div>   1、 使用Lock机制取代synchronized代码块和synchronized方法</div><div>   2、使用Condition接口对象的await，signal，signalAll取代Object类中的wait，notify，notifyAll方法</div><div>Lock更加体现面向对象，Lock接口是没有锁对象的，需要手动去获取和释放</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程通信-wait和notify方法介绍</h1>
  </td></tr>
</table>
<div>java.lang.Object类提供了两类用于操作线程通信的方法</div><div>wait()：执行该方法的线程对象释放同步锁，JVM把该线程存放到等待池中，等待其他的线程唤醒该线程</div><div>notify()：执行该方法的线程对象唤醒在等待池中等待的任意一个线程，把线程转到锁池中等待</div><div>notifyAll()：执行该方法的线程唤醒在等待池中等待的所有线程，把线程转到锁池中等待</div><div>注意：上述方法只能被同步监听锁对象来调用，否则报错IllegalMonitorStateExcepiton</div><div><hr/>假设A线程和B线程共同操作一个x对象，对象A，B线程可以通过x对象的wait方法和notify方法来进行通信，流程如下：</div><div>1、当线程A执行x对象的同步方法时，A线程持有x对象的锁，B线程在x对象的锁池中等待</div><div>2、A线程在同步方法中执行x，wait()方法时，A线程释放x对象的锁，进入x对象的等待池</div><div>3、在x对象的锁池中等待锁的B线程获取x对象的锁，执行x的另一个同步方法</div><div>4、B线程在同步方法中执行x.notify()方法时，JVM吧A线程从x对象的等待池中移动到x对象的锁池中，等待获取锁</div><div>5、B线程执行完同步方法，释放锁，A线程获得锁，继续执行同步方法</div><div><hr/>多个线程只有使用相同的一个对象的时候，多线程之间才有互斥效果，我们把这个用来做互斥的对象称之为同步监听对象</div><div><hr/>同步锁对象可以选择任意类型的对象即可，只需要保证多个线程使用的是相同的锁对象即可</div><div><hr/>因为只有同步监听锁对象才能调用wait()和notify()方法，所以wait和notify方法应该存在于Object类中，而不是Thread类中</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程通信-解决性别紊乱问题</h1>
  </td></tr>
</table>
<div>分析生产者和消费者案例存在的问题：</div><div/><div/><div/><div>    1、出现性别紊乱的情况</div><div>        解决方案：只要保证在生产姓名和性别的过程保持同步，中间不能被消费者线程进来取走数据</div><div>                          可以使用同步代码块，同步方法，锁机制来保持同步性<br/></div><div>    2、应该出现生产一个数据，消费一个数据</div><div>         应该交替出现</div><div>        解决方案：得使用等待和唤醒机制</div><hr/><div>同步锁池：</div><div>    同步锁必须选择多个线程共同的资源对象</div><div>    <br/></div><div>    当生产者在生产数据的时候（先拥有同步锁），其他线程就在锁池中等待获取锁<br/></div><div>    当线程执行完同步代码块的时候，就会释放同步锁，其他线程开始抢夺锁的使用权<br/></div><div><a href="%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/App1.java">App1.java</a><br/></div><div><a href="%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/Consumer1.java">Consumer1.java</a><br/></div><div><a href="%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/Producer1.java">Producer1.java</a><br/></div><div><a href="%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/ShareResource1.java">ShareResource1.java</a><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>线程通信-生产者和消费者案例分析</h1>
  </td></tr>
</table>
<div>线程通信：不同的线程执行不同的人物，如果这些任务有某种关系，线程之间必须能够通信，协调完成工作</div><div>经典的生产者和消费者案例（Producer／Consumer）：</div><div>    分析案例：</div><div>        1、生产者和消费者应该操作共享的资源（实现方式来做）</div><div>        2、使用一个或多个线程来表示生产者<br/></div><div>        3、使用一个或多个线程来表示消费者</div><div><br/></div><div><br/></div></body></html>