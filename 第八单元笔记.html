<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.12.3 (455521)"/><meta name="altitude" content="1530.873046875"/><meta name="author" content="923435274@qq.com"/><meta name="created" content="2017-07-27 02:03:37 +0000"/><meta name="latitude" content="36.0799710988984"/><meta name="longitude" content="103.8517916098646"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-07-30 14:38:34 +0000"/><title>第八单元笔记</title></head><body>


<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>组合关系</h1>
  </td></tr>
</table>
<div>继承关系：子类可以继承到父类中部分的成员，那么此时子类是可以修改到父类的信息的</div><div><font style="font-weight: bold;" color="#0433ff">继承关系破坏封装，</font>为了复用代码可能会让子类具有不该具有的功能<br/></div><div><hr style="color: rgb(4, 51, 255); font-weight: bold;"/>为什么引入继承：为了代码复用问题</div><div>解决代码复用问题，不一定非要使用继承，也可以使用“包含关系”（has A）</div><div><b>我没钱，但是我想开豪车，我想吃火锅：</b></div><div><span>    方式1:认一个富豪干爹（继承关系）</span><br/></div><div><span><span>    方式2:把一个富豪绑架在我家里，挟天子以令诸侯（组合关系／包含关系）</span></span></div><div><span><span><hr/>如果A类为了得到B类的功能行为：</span></span></div><div><span><span><span>    如果A类是B类的一种特殊情况，我们就应该采用继承来实现</span></span></span></div><div><span><span><span><span>    否则使用组合方式</span></span></span></span></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>引用类型转换和instanceof运算符</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079964,103.851736"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>基本数据类型转换：</div><div>    1、自动类型转换：把小类型的数据赋给大类型的变量（此时的大和小表示容量范围）</div><div>    byte b=12；byte是一个字节</div><div>    int i=b；int是4个字节</div><div>    2、强制类型转换：把小类型的数据赋给小类型的变量</div><div>    short s=(short)i；short是两个字节</div><hr/><div>引用类型的转换：</div><div>    引用类型的大和小，指的是父类和子类的关系</div><div>    自动类型转换：把子类对象赋给父类变量（多态）</div><div>        Animal a=new Dog();</div><div>        Object是所有类的根类</div><div>        Object obj=new Dog();<br/></div><div>    强制类型转换：把一个父类类型的对象赋给子类类型的变量（但是该父类类型变量的真实类型应该是子类类型）</div><div>    Animal a=new Dog();</div><div>    Dog d=(Dog)a;<br/></div><div><hr/>instanceof运算符：判断该对象是否是某一个类的实例</div><div>语法格式：boolean b=对象A instanceof 类B;//判断A对象是否是B类的实例</div><div><hr/>instanceof运算符：</div><div><span>    若对象是类的实例返回true</span><br/></div><div><span><span>    若对象是父类的实例也返回true</span><br/></span></div><div><span><span><hr/>在开发中我们只想判断是真实类型的实例，而不像判断为编译类型的实例</span></span></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>多态时方法调用问题</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079946,103.851695"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>前提：必须先存在多态情况</div><div>存在父类：SuperClass，子类：SubClass，方法：doWork</div><div><hr/>测试代码：</div><div>Super class clz=new SubClass();//多态</div><div>clz.doWork();//输出什么</div><div><hr/>情况1:doWork存在于SuperClass中，不存在SubClass中</div><div>//父类</div><div>class SuperClass{</div><div>    public void doWork(){</div><div>        System.out.println("Super.doWork");</div><div>    }</div><div>}</div><div><br/></div><div>//子类</div><div>class SubClass extends SuperClass{</div><div><br/></div><div>}</div><div>此时执行结果是：编译通过，执行SuperClass的doWork方法</div><div><span>    应该先从SubClass中去找doWork方法，找不到再到父类中去找</span><br/></div><hr/><div>情况2:doWork存在于SbClass中，不存在SuperClass中</div><div>//父类</div><div>class SuperClass{</div><div>    </div><div>}</div><div><br/></div><div>//子类</div><div>class SubClass extends SuperClass{</div><div>    public void doWork(){</div><div>        System.out.println("SubClass.doWork");</div><div>    }</div><div>}</div><div>此时执行结果是：编译报错<br/></div><div><span>    编译时期会去编译类型（SuperClass）中找是否有doWork方法：</span><br/></div><div><span><span>    <span>    找到：编译通过</span></span><br/></span></div><div><span><span><span><span>    <span>    找不到：编译报错</span></span><br/></span></span></span></div><hr/><div>情况3:doWork存在于SuperClass中，也存在SubClass中<br/></div><div><span><span><span><span><span>//父类</span></span></span></span></span></div><div>class SuperClass{</div><div>    public void doWork(){</div><div>        System.out.println("SuperClass.doWork");</div><div>    }</div><div>}</div><div><br/></div><div>//子类</div><div>class SubClass extends SuperClass{</div><div>    public void doWork(){</div><div>        System.out.println("SubClass.doWork");</div><div>    }</div><div><span><span><span><span><span><br/></span></span></span></span></span>}</div><div>编译通过，执行SubClass的doWork方法<br/></div><div><span>    在运行时期，调用运行类型（SubClass）中的方法</span><br/></div><hr/><div>情况4:doWork存在于SuperClass中，也存在SubClass中，但是doWork是静态方法<br/></div><div><span>    <span>    此时这种情况我们称之为隐藏，而不叫做方法的覆盖</span></span><br/></div><div>//父类</div><div>class SuperClass{</div><div>    static public void doWork(){</div><div>        System.out.println("SuperClass.doWork");</div><div>    }</div><div>}</div><div><br/></div><div>//子类</div><div>class SubClass extends SuperClass{</div><div>    static public void doWork(){</div><div>        System.out.println("SubClass.doWork");</div><div>    }</div><div>}</div><div>此时执行结果是：编译通过，执行SuperClass的doWork方法<br/></div><div><span>    静态方法的调用只需要类即可</span><br/></div><div><span>    </span>如果使用对象调用静态方法，其实是使用对象的编译类型来调用静态方法</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>多态的好处</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079880,103.851594"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>需求：给饲养员提供一个喂养动物的方法，用于喂养动物</div><div><font color="#0433ff">没有多态：</font></div><div><span>    发现，针对不同类型的动物，我们得提供不同feed方法来喂养</span><br/></div><div><span><span>    不优雅</span><br/></span></div><div><br/></div><div>    <font color="#0433ff">我想，只提供一个方法，就可以统一喂养所有动物</font><br/></div><div><font color="#ff2600"><br/></font></div><div><font color="#ff2600">存在多态：</font></div><div><font color="#0433ff">统一了喂养动物的行为</font></div><div><font color="#0433ff">从上述例子，可以得知多态的作用：当把不同的子类对象都当作父类类型来看待，可以屏蔽不同子类对象之间的差异，从而写出通用的代码达到通用编程，以适应需求的不断变化</font></div><hr/><div><font>//普通动物</font></div><div>class Animal{</div><div>    public void eat(){</div><div>        System.out.println("吃一般的食物");</div><div>    }</div><div>}</div><div><br/></div><div>//狗</div><div>class Dog extends Animal{</div><div>    public void eat(){</div><div>        System.out.println("吃肉骨头");</div><div>    }</div><div>}</div><div>//猫</div><div>class Cat extends Animal{</div><div>    public void eat(){</div><div>        System.out.println("吃鱼");</div><div>    }</div><div>}</div><div>//饲养员</div><div>class Person{</div><div>    //喂养狗的方法</div><div>    public void feed(Animal a){</div><div>        System.out.println("喂食。。。");</div><div>        a.eat();</div><div>    }</div><div>}</div><div>//引出多态</div><div>class AnimalDemo{</div><div>    public static void main(String[] args){</div><div>        Dog d=new Dog();</div><div>        //创建饲养员对象</div><div>        Person p=new Person();</div><div>        p.feed(d);//饲养员给狗喂食</div><div>        //创建猫对象</div><div>        Cat c=new Cat();</div><div>        p.feed(c);</div><div><br/></div><div>    }</div><div>}</div><div><font><br/></font><br style="color: rgb(4, 51, 255);"/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>理解多态思想</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079922,103.851674"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>学了继承关系我们知道，继承关系是一种“is A”的关系，也就是说子类是父类的一种特殊情况</div><div><br/></div><div>既然子类是一种特殊的父类，我们可不可以认为狗对象／猫对象就是动物类型的对象</div><div>Dog d=new Dog();//创建一只狗对象</div><div>Cat c=new Cat();//创建一只猫对象</div><hr/><div>当我的代码变成以下样子的时候，多态就产生了：</div><div><span style="color: rgb(255, 38, 0);">Animal a=new Dog();</span></div><div><br/></div><div><span style="font-weight: bold;">对象具有两种类型：</span></div><div>编译类型：声明对象变量的类型，Animal，表示把对象看成什么类型</div><div>运行类型：对象的真实类型，Dog，运行类型——&gt;对象的真实类型</div><div><br/></div><div>编译类型必须是运行类型的父类／或相同</div><div>当编译类型和运行类型不同的时候，多态就出现了</div><div>所谓多态：对象具有多种形态，对象<span style="color: rgb(255, 38, 0);">可以</span>存在不同的形式</div><div><span style="color: rgb(255, 38, 0);">Animal a=null;</span></div><div><span style="color: rgb(255, 38, 0);">    </span><span style="color: rgb(255, 38, 0);">    </span><span style="color: rgb(255, 38, 0);">    </span><span style="color: rgb(255, 38, 0);">a=new Dog();//a此时表示Dog类型的形态</span></div><div><span style="color: rgb(255, 38, 0);">    </span><span style="color: rgb(255, 38, 0);">    </span><span style="color: rgb(255, 38, 0);">    a=new Cat();//a此时表示Cat类型的形态</span><br/></div><div>多态的前提：可以是继承关系（类和类）／也可以是实现关系（接口和实现类），在开发中多态一般都指第二种</div><hr/><div>多态的特点：</div><div>        把子类对象赋给父类的变量，在运行时期会表现出具体的子类特征</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>Object类和常用方法</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079922,103.851674"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>Object类是java语言的根类，要么是一个类的直接父类，要么就是一个类的间接父类</div><div>class ABC{}其实等价于class ABC extends Object{}</div><div><hr/></div><div>所有对象（包括数组）都实现这个类的方法，这句话怎么理解？</div><div><hr/><font color="#0433ff">为什么Object类是所有类的根类，到底什么是Object？</font></div><div>Object本身指对象的意思，我们发现所有的对象都具有某一些共同的行为，所以我们抽象出一个类：Object，表示对象类，其他类都会继承于Object类，也就拥有Object中的方法</div><div><br/></div><div>注意：引用数据类型：类／数组／接口，引用类型又称之为对象类，所谓的数组变量名称，应该指数组对象，对象都存在于堆空间中</div><div><br/></div><div>Object类的常见方法：</div><div><b>1、protected void finalize()</b>：当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</div><div><span>    <span>    <span>    垃圾回收器在回收某一个对象之前，会先调用该方法，做扫尾操作，该方法我们不要去调用</span></span></span><br/></div><div><span><span><b>2、Class getClass()</b>:返回当前对象的真实类型</span></span></div><div><span><b>3、int hashCode()</b>:返回该对象的哈希码值，hashCode决定了对象在哈希表中的存储位置，不同对象的hashCode是不一样的</span></div><div><b>4、boolean equals(Object obj)</b>:拿<font color="#0433ff">当前对象（this）和参数（obj）比较</font></div><div><font color="#0433ff">                   </font> 在Object类中的equals方法，本身和“==”符号相同，都是比较对象的内存地址<span>    <span>    </span></span><br/></div><div><span><span><span>    <span>    <span>    <span>    <span>    官方建议：每个类都应该覆写equals方法，不要去比较内存地址，而去比较我们关心的数据，因为我们关心的是数据，而不是内存</span></span></span></span></span><br/></span></span></div><div><span><span><span><span><span><span><span><span>    <span>    <span>    <span>    <span>    比如两个学生对象，我们不管是如何new出来的，只要学号相同就认为是同一个对象</span></span></span></span></span><br/></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    <span>    <span>    <span>    <span>    <span>    两个字符串只要内容相同，我们iu认为是同一个字符串</span></span></span></span></span></span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><b>5、toString()</b>:表示把一个对象转换为字符串</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    打印对象的时候其实打印的就是对象的toString方法</span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    System.out.println（obj对象）等价于System.out.println（obj对象.toString）</span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    默认情况下打印对象打印的是对象的16进制的hashCode值，但是我们更关心对象中存储的数据，所以官方建议我们：每个类都应该覆盖toString，返回我们关心的数据</span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><hr/><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>//演示Object类中的方法</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>class Hello{</div><div>    public static void main(String[] args){</div><div>        String str1=new String("AA");</div><div>        String str2="AA";</div><div><br/></div><div>        Object o1=new Object();</div><div>        Object o2=new Object();</div><div><br/></div><div>        System.out.println(str1.equals(str2));//true</div><div>        System.out.println(o1.equals(o2));</div><div><br/></div><div>        User u=new User("Will",17);</div><div>        System.out.println(u);//</div><div>        System.out.println(u.toString);</div><div>    }</div><div>}</div><div>class ObjectDemo{</div><div>    private String name;</div><div>    private int age;</div><div>    User(String name,int age){</div><div>        this.name=name;</div><div>        this.age=age;</div><div>    }</div><div>    public String toString(){</div><div>        return this.name+","+this.age;</div><div>    }</div><div>}</div><div><br/></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>super应用场景和各种隐藏现象</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079952,103.851747"><b>Map</b></a><br/>
  </td></tr>
</table>
<div><font color="#0433ff">super应用场景：</font></div><div><font color="#0433ff">1、可以使用super解决子类隐藏了父类的字段，这种情况我们一般不讨论，因为破坏封装</font></div><div><font color="#ff2600">2、在子类方法中，调用父类被覆盖的方法，引出super的例子，此时必须使用super</font></div><div><font color="#0433ff">3、在子类构造器中，调用父类构造器，此时必须使用super语句：</font><font color="#ff2600">super[实参]</font></div><div><br/></div><div>所谓隐藏就是“遮蔽”的意思：</div><div>1、满足继承的访问权限下，隐藏父类<font color="#ff2600">静态方法</font>：若子类定义的静态方法的签名和超类中的静态方法名相同，那么此时就是隐藏父类方法，<font color="#ff2600">注意：仅仅是静态方法,子类存在父类一摸一样的静态方法</font></div><div><br/></div><div>2、满足继承的访问权限下，隐藏父类字段：若子类中定义的字段和超类中的字段名相同（不管类型），此时就是隐藏父类字段，此时只能通过super访问被隐藏的字段</div><div><br/></div><div>3、隐藏本类字段：若同类中某局部变量名和字段名相同，此时就是隐藏本类字段，<font color="#0433ff">此时只能通过this访问被隐藏的字段</font></div><div><hr style="color: rgb(4, 51, 255);"/>static不能和super和this共存</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>子类初始化过程</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079968,103.851734"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>子类初始化过程：创建子类对象的过程</div><div><span>    在创建子类对象之前，会先创建父类对象</span><br/></div><div><span>   <font color="#0433ff"> 调用子类构造器之前，在子类构造器中会先调用父类的构造器，默认调用的是负累无参数构造器</font></span></div><div><span>    </span></div><div><span>1、如果父类不存在可以被子类访问的构造器则不能存在子类</span></div><div>2、如果父类没有提供无参数构造器，此时子类必须显示通过super语句去调用父类带参数的构造器</div><div>注意：<font color="#ff2600">必须先有父类对象，而后才能有子类对象，必须先调用父类构造器再调用子类构造器</font></div><hr/><div><font>/动物</font></div><div>class Animal{</div><div>    private String name;</div><div>    private int age;</div><div><br/></div><div>    public Animal(String name,int age){</div><div>        System.out.println("Animal的构造器");</div><div>        this.name=name;</div><div>        this.age=age;</div><div>    }</div><div>    public String getName(){</div><div>        return name;</div><div>    }</div><div>}</div><div><br/></div><div>//鱼</div><div>class Fish extends Animal{</div><div>    private String color;//颜色</div><div><br/></div><div>    Fish(String name,int age,String color){</div><div>        super(name,age);</div><div>        this.color=color;</div><div>    }</div><div>    public void say(){</div><div>        System.out.println(this.getName()+","+color);</div><div>    }</div><div>}</div><div><br/></div><div>//子类初始化过程：创建子类对象的过程</div><div>class SubClassInitDemo{</div><div>    public static void main(String[] args){</div><div>        //创建鱼对象</div><div>        Fish f=new Fish("尼莫",5,"橘黄色");</div><div>        f.say();</div><div>    }</div><div>}</div><div><br/></div><div><font><br/></font><br style="color: rgb(255, 38, 0);"/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>理解super关键字</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079998,103.851837"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>需求：在子类中的某一个方法中调用父类被覆盖的方法</div><div><br/></div><div>此时的解决方案：使用super关键字</div><div>什么是super：</div><div>this：当前对象，谁调用this所在的方法，this就是哪一个对象</div><div>super：当前对象的父类对象</div><hr/><div>//鸟类</div><div>class Bird extends Object{</div><div>    public void fly(){</div><div>        System.out.println("飞翔");</div><div>    }</div><div>}</div><div><br/></div><div>//企鹅</div><div>class Penguin extends Bird{</div><div>    //重新定义fly</div><div>    public void fly(){</div><div>        System.out.println("飞不起");</div><div>    }</div><div>    public void say(){</div><div>        //调用Bird类中的fly方法：Bird:fly</div><div>        System.out.println("我要唱歌");</div><div>        super.fly();</div><div>    }</div><div>}</div><div><br/></div><div>//super关键字</div><div>class SuperDemo{</div><div>    public static void main(String[] args){</div><div>        Penguin p=new Penguin();</div><div>        p.say();</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>方法重载荷方法覆盖的区别</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.080003,103.851816"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>方法重载：Overload</div><div>方法重写：Override</div><div>批判：本身二者一点关系都没有，仅仅只是因为名字很像而已</div><hr/><div><font color="#0433ff">方法重载：Overload</font><br/></div><div><span>    作用：解决了同一个类中相同功能的方法名不同的问题</span><br/></div><div><span><span>    <span>    <span>    既然是相同的功能，那么方法的名字就应该相同</span></span></span><br/></span></div><div><span><span><span><span><span>    规则：两同一不同</span><br/></span></span></span></span></div><div><span><span><span><span><span><span>    <span>    <span>    同类中，方法名相同，方法参数列表不同（参数类型，参数个数，参数顺序）</span></span></span><br/></span></span></span></span></span></div><div><br/></div><div><font color="#0433ff">方法重写：Override</font><br/></div><div><span>    作用：解决子类继承父类之后，可能父类的某一个方法不满足子类的具体特征，此时重新在子类中定义该方法并重写方法体</span><br/></div><div><span><span>    规则：一同两小一大</span><br/></span></div><div><span><span><span>    <span>        <font color="#ff2600">一同：父类和子类的方法签名是相同的，建议：直接拷贝父类的方法定义到子类，再重写方法体就ok了</font></span></span><font color="#ff2600"><br/></font></span></span></div><div><span><span><span><span><font color="#ff2600"><br/></font></span></span></span></span></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>方法覆盖</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079980,103.851830"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>场景：</div><div>子类拓展父类，可以获得父类的部分方法和成员变量，可是当父类的某个方法不适合子类本身的特征是，此时该怎么办？</div><div>如：企鹅和鸵鸟是鸟类中的一个特殊品种，所以企鹅／鸵鸟是鸟的一个子类，但是鸟类有飞的功能，但是对应企鹅／鸵鸟，飞翔行为显然不适合它</div><div><hr/>方法覆写的原则（一同两小一大）：</div><div><span>     <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">一同：</span></span></div><div><span><span>    </span> 1、方法的签名必须相同，签名相同（名称相同，参数列表相同）</span><br/></div><div><span>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">两小：</span></span></div><div><span>    1、子类方法的返回值类型是和父类方法的返回类型相同或者是其子类</span><br/></div><div><span><span>    <span>    <span>    子类可以返回一个更加具体的类</span></span></span><br/></span></div><div><span><span>    2、子类方法声明抛出的异常类型和父类方法声明抛出的异常类型相同或者是其子类</span></span></div><div>子类方法中声明抛出的异常小于或等于父类方法声明抛出异常类型</div><div>子类方法可以同时声明抛出多个属于父类方法声明抛出异常类的子类（RuntimeException类型除外）</div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">一大：</span><br/></div><div><span><span>    1、子类方法的访问权限比父类方法访问权限更大或相等</span></span></div><div>private修饰的方法不能被子类继承，也就不存在覆盖的概念<br/></div><div><br/></div><div>判断是否覆写方法的必杀技：@Override标签：若方法是覆写方法，在方法前或上贴上该标签，编译通过，否则，编译出错</div><div>只用方法存在覆盖的概念，字段没有覆盖</div><div>方法覆盖解决的问题：当父类的某一个行为不符合子类具体的特征的时候，此时子类需要重新定义父类的方法，并重写方法体</div><hr/><div>//鸟类</div><div>class Bird extends Object{</div><div>    public void fly(){</div><div>        System.out.println("飞翔");</div><div>    }</div><div>}</div><div><br/></div><div>//企鹅</div><div>class Penguin extends Bird{</div><div>    //重新定义fly</div><div>    @Override</div><div>    public void fly(){</div><div>        System.out.println("飞不起");</div><div>    }</div><div>}</div><div><br/></div><div>//方法覆盖</div><div>class OverrideDemo{</div><div>    public static void main(String[] args){</div><div>          //创建一个企鹅对象，并调用其飞翔的方法</div><div>        Penguin p=new Penguin();</div><div>        //先从子类中寻找fly方法，如果找到就执行</div><div>        //如果找不到就到父类去找</div><div>        p.fly();//</div><div>    }</div><div>}</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>子类继承了父类的那些成员</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079976,103.851734"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>先写父类还是先写子类：</div><div>    一般的我们在开发过程中先编写多个自定义类，写完后发现多个类之间存在共同的代码，此时可以抽取中一个父类。</div><div>    我们以后做开发都是基于框架和组件来做的，我们是在别人的基础之上继续做开发，好比别人提供清水房，我们只需要在清水房的基础之上装修，就可以使用，以后我们会定义新的类，去继承于框架中／组件中提供的父类，</div><hr/><div>子类继承父类以后可以拥有父类的某一些状态和行为（子类复用了父类的功能或状态）</div><div>子类继承了父类的哪些成员（根据访问修饰符来判断）：</div><div>        1、如果父类中的成员是使用public修饰，子类继承</div><div>        2、如果父类中的成员使用protected修饰，子类也继承，即使父类和子类不在同一个包中<br/></div><div>        3、如果父类和子类在同一个包中，此时子类可以继承父类中缺省修饰符的成员<br/></div><div>        4、如果父类中的成员使用private修饰，子类无法继承到，因为private只能在本类中访问</div><div>        5、父类的构造器，子类也不能继承，因为构造器必须和当前的类名相同<br/></div><div><br/></div><div>请注意：不要去背文字，立马写代码去证明</div><hr/><div>class Person{</div><div>    protected String name;</div><div>    int age;</div><div>    void sleep(){</div><div>    }</div><div>}</div><div><br/></div><div>class Student extends Person{</div><div>    String sn;//学号</div><div>}</div><div><br/></div><div><br/></div><div>public class ExtendsDemo{</div><div>    public static void main(String[] args){</div><div>       Student s=new Student();</div><div>       System.out.println(s.age);</div><div>       System.out.println(s.sn);</div><div>       System.out.println(s.name);</div><div><br/></div><div>       s.sleep();</div><div>    }</div><div>}</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>引出／理解继承关系</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079953,103.851731"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>被继承的类：super class（父类／超类／基类／被拓展类）</div><div>sub class：子类／拓展类</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">父类：存放的共性（共同的特性（状态／行为））</span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">子类：存放的特性（自己特有的特性（状态／行为））</span></div><div><br/></div><div>继承关系解决：</div><div>    解决了代码重复的问题</div><hr/><div>什么是继承关系：</div><div>基于某个父类对对象的定义加以拓展，而产生新的子类定义，子类可以继承父类原来的某些定义，也可以怎家原来父类所没有的定义，活着覆写父类中的某些特性</div><div><br/></div><div>从面向对象的角度上说：继承是中从一般到特殊的关系，是一种“is a”的关系，即子类是父类的拓展，是一种特殊的父类，比如：狗是动物的一种特殊情况，狗属于动物</div><div><hr/>在java中存在多个类的时候，我们使用<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">extends</span><span style="">关键字</span></div><div>语法格式：在定义子类的时候表明自己需要拓展于哪一个父类</div><div>public class 子类类名 extends 父类类名{</div><div><span>    编写自己特有的状态和行为</span><br/></div><div>}</div><div><hr/>在java中类和类之间的继承关系只允许单继承，不允许多继承</div><div>也就是说一个类A，只能有一个直接的父类，不能出现类A同时继承于类B和类C</div><div><span>    但是java允许多重继承</span><br/></div><div>多重继承的例子：</div><div><span>    动物有胎生动物和卵生动物，胎生动物有老虎，老虎又氛围华南虎，东北虎，孟加拉虎等</span><br/></div><div><hr/>在java中除了Obiect类以外，每个类都有一个直接的父类</div><div>比如：class Student extends Person{}</div><div>我们就说此时Student的直接父类是Person</div><div>问题：class Person{}此时Person的父类又是谁？</div><div>Object类是java语言的根类（老祖宗，任何类都是Object类的子类）</div><div>class Person{}等价于class Person extends Object{}</div><div><span>    Object类要么是一个类的直接父类，要么是一个类的直接父类</span><br/></div><div><span><br/></span></div><div>继承关系的作用：</div><div><span>    <span>    1、解决了代码的重复问题</span></span><br/></div><div><span><span><span>    <span>    2、真正的作用，表示出一个体系</span></span><br/></span></span></div><div><br/></div></body></html>