<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.12.3 (455521)"/><meta name="altitude" content="1530.1005859375"/><meta name="author" content="923435274@qq.com"/><meta name="created" content="2017-07-31 00:37:28 +0000"/><meta name="latitude" content="36.07995556219037"/><meta name="longitude" content="103.8517227307353"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-08-01 11:22:32 +0000"/><title>第九单元笔记</title></head><body>


<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>引出／分析模版方法设计模式</h1>
  </td></tr>
</table>
<div>需求：统计不同操作的耗时时间模版操作</div><div>OperateTimeTemplate</div><div><hr/>模版方法设计模式：在父类的一个方法中定义一个总体的算法骨架（模版方法），<font color="#ff2600">而将某一些步骤延迟到子类中来，因为不同的子类实现细节不同</font>，模版方法使得子类可以在不该拜年算法结构的情况下，重新定义算法中的某些步骤</div><div><hr/>抽象父类负责定义操作中的业务骨架，把某些具体的实现步骤延迟到子类去实现</div><div>抽象父类至少提供的方法：</div><div>1、模版方法：一种通用的处理方式，即模版（总体算法的骨架）</div><div>2、抽象方法：一种具体的业务功能实现，由子类完成</div><div>注意：抽象父类提供的模版方法知识定义了一个通用算法，其实现必须依赖子类的辅助</div><div>模版方法作为模版样式不准子类覆写，怎么办？抽象方法的权限又如何设置？</div><hr/><div>//操作的模版类</div><div>abstract class AbstractOperateTimeTemplate</div><div>{</div><div>    //模版方法：总体算法的骨架，子类不能修改</div><div>    final public long getTotalTime()</div><div>    {</div><div>        long begin=System.currentTimeMillis();//开始时间</div><div>        //具体操作（留给子类去完成）</div><div>        doWork();</div><div>        long end=System.currentTimeMillis();//结束时间</div><div>        long time=end-begin;</div><div>        return time;</div><div>    }</div><div>    //具体操作，子类必须覆盖</div><div>    abstract void doWork();</div><div>}</div><div>//String的连接10000次</div><div>class StringOperate extends AbstractOperateTimeTemplate</div><div>{</div><div>    protected public void doWork()</div><div>    {</div><div>        String str="";</div><div>        for(int i=0;i&lt;10000;i++){</div><div>            str+=i;</div><div>        }</div><div>    }</div><div>}</div><div>class IntOperate extends AbstractOperateTimeTemplate</div><div>{</div><div>    protected public void doWork()</div><div>    {</div><div>        int sum=0;</div><div>        for(int i=0;i&lt;100000;i++){</div><div>            sum=sum+1;</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>//模板方法设计模式</div><div>public class OperateTimeTemplate</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //统计字符串连接10000次和int相加10000次的时间差</div><div>        System.out.println(new IntOperate().getTotalTime());</div><div>        System.out.println(new StringOperate().getTotalTime());</div><div>    }</div><div>}</div><div><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>抽象方法和抽象类</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079956,103.851732"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>使用abstract修饰且没有方法体的方法，称为抽象方法</div><div>特点：</div><div>    1、使用抽象abstract修饰，方法没有方法体，留给子类去实现</div><div>    2、抽象方法<span style="color: rgb(4, 51, 255);">修饰符不能是private和final以及static</span>，为什么？<br/></div><div>    3、抽象方法必须定义抽象类或接口中</div><div>一般的：习惯把abstract卸载方法修饰符最前面，一看就知道是抽象方法</div><div><br/></div><div>注意：抽象类必须有子类才有意义，才能完成自己的抽象方法</div><hr/><div>使用abstract关键字的类</div><div>特点：</div><div>    1、不能创建实例即不能new一个抽象类（抽象类还是有构造器的），即使创建出抽象类对象，调用抽象方法，根本没有方法体</div><div>    2、可以不包含抽象方法，若一旦包含，该类必须作为抽象类，抽象类可以包含普通方法，（<span style="font-weight: bold;">留给子类调用的</span>），子类构造器要先调用父类构造器<br/></div><div>    3、若子类没有实现／覆盖父类所有的抽象方法，那么子类也得作为抽象类（抽象派生类）<br/></div><div>    4、<span style="color: rgb(4, 51, 255);">构造方法不能都定义为私有的，否则不能有子类（创建子类对象前先调用父类构造方法）</span><br/></div><div>    5、抽象类不能使用final修饰，因为必须有子类，抽象方法才能实现</div><div>    6、抽象类是不完整的类，需作为父类（<span style="font-weight: bold;">必须要有子类</span>），功能才得以实现<br/></div><div>抽象类：一般的我们起名，习惯使用Abstract作为前缀，让调用者一看就知道是抽象类</div><div><span style="font-weight: bold;">抽象类中可以不存在抽象方法</span>，这样的话没有太大的意义，防止外界创建对象，所以我们会发现有些工具类没有抽象方法，但是也使用abstract来修饰</div><hr/><div>抽象类不能实例化</div><hr/><div>抽象类和普通类的区别：</div><div>    普通类有的成员（方法，字段，构造器）抽象类都有</div><div>    抽象类不能创建对象，抽象类中可以包含抽象方法</div><hr/><div>abstract class Graph</div><div>{</div><div>    Graph(){};</div><div>    //求面积</div><div>    void doWork()</div><div>    {</div><div><br/></div><div>    }</div><div>    abstract public Double getArea();</div><div>}</div><div>//圆</div><div>class Circle</div><div>{</div><div>    private Integer r;</div><div>    Circle(int r)</div><div>    {</div><div>        this.r=r;</div><div>    }</div><div><br/></div><div>    public Double getArea()</div><div>    {</div><div>        return 3.14*r*r;</div><div>    }</div><div>}</div><div>//矩形</div><div>class Rectanle</div><div>{</div><div>    private Integer width;//长度</div><div>    private Integer height;//高度</div><div><br/></div><div>    Rectanle(Integer width,Integer height)</div><div>    {</div><div>        this.width=width;</div><div>        this.height=height;</div><div>    }</div><div>    public Double getArea(){</div><div>        return width*height.doubleValue();</div><div>    }</div><div>}</div><div>//三角形</div><div>class Triangle extends Graph</div><div>{</div><div>    private Integer a;</div><div>    private Integer b;</div><div>    private Integer c;</div><div><br/></div><div>    Triangle(Integer a,Integer b,Integer c)</div><div>    {</div><div>        this.a=a;</div><div>        this.b=b;</div><div>        this.c=c;</div><div>    }</div><div>    public Double getArea(){</div><div>        Double p=(a+b+c)/2.0;</div><div>        return Math.sqrt(p*(p-a)*(p-b)*(p-c));</div><div>    }</div><div>}</div><div>public class AbstractDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        System.out.println(new Circle(10).getArea());</div><div>        System.out.println(new Rectanle(10,20).getArea());</div><div>        System.out.println(new Triangle(3,4,5).getArea());</div><div><br/></div><div>        //new Graph();//错误: Graph是抽象的; 无法实例化</div><div>    }</div><div>}</div><div><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>引出抽象方法</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079954,103.851726"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>案例：求圆（circle），矩形（rectangle），三角形（Triangle）的面积？</div><div>问题：</div><div>    1、每一个图形都有面积，所以在Graph类中定义求面积的方法getArea没问题，但是不同的具体图形求面积的算法是不一样的，也就是说每一个图形的子类都必须去覆盖getArea方法，<font color="#ff2600">如果不覆盖应该语法报错，必须覆盖</font><br/></div><div><font color="#ff2600">    </font>2、在图形类中定义了getArea方法，该方法不应该存在方法体，<font color="#0433ff">因为不同图形子类求面积算法不一样，父类不知道怎么写，所以应该提供无方法体</font><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>Integer和int的区别</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079903,103.851639"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>Integer和int的区别<font color="#0433ff">（包装类和基本数据类型的区别）</font>：</div><div><span>    1、默认值：</span><br/></div><div><span><span>    <span>    int的默认值是0</span></span><br/></span></div><div><span><span><span><span>    <span>    Integer默认值为null</span></span><br/></span></span></span></div><div><span><span><span><span><span><span>    <span>    <span>    推论：Integer既可以表示null，又可以表示0</span></span></span><br/></span></span></span></span></span></div><div><span>    2、包装类中提供了该类型相关的很多算法</span><br/></div><div><span><span>    <span>    <span>    s</span></span></span>tatic String toBinaryString(int i):把十进制转换为二进制</span></div><div><span><span>    <span>    <span>    static String toOctalString(int i):把十进制转换为八进制</span></span></span><br/></span></div><div><span><span><span><span><span>    <span>    <span>    static String toHexString(int i):把十进制转换为十六进制</span></span></span><br/></span></span></span></span></div><div><span>    3、集合框架中只能存储对象类型，不能存储基本数据类型值</span><br/></div><div><span><br/></span></div><div><span><span>    </span>4、请问：Integer和int是相同的数据类型吗？</span></div><div><span><span>    <span>    不同的数据类型</span></span><br/></span></div><div><span>    <span>    对象.ooxx(17);</span></span><br/></div><div><span><span><span>    5、方法中的基本类型变量主要存储在栈中，包装类型存放于堆中</span><br/></span></span></div><div><span><span><br/></span></span></div><div>开发中，建议使用包装类型</div><hr/><div>public class IntegerDemo</div><div>{</div><div>    public void ooxx(int cal){}</div><div>    public void ooxx(Integer cal){}</div><div>    public static void main(String[] args)</div><div>    {</div><div>        Integer num=null;</div><div>        num=0;</div><div>        System.out.println(Integer.toBinaryString(999999));</div><div>        System.out.println(Integer.toOctalString(123));</div><div>    }</div><div>}</div><div><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>包装类的缓存设计</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.079928,103.851682"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>包装类的缓存设计（享元模式），本质就是缓存设计</div><div>Byte，Short，Integer，Long：缓存[-128,127]之间的数据</div><div>Character：缓存[0,127]之间的数据</div><div><br/></div><div>包装类型对象之间的比较操作：统统使用equals方法来做比较，比较的是包装的数据</div><hr/><div>//包装类操作</div><div>public class CacheDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        Integer i1=new Integer(123);</div><div>        Integer i2=new Integer(123);</div><div>        System.out.println(i1==i2);//false</div><div><br/></div><div>        Integer i3=Integer.valueOf(123);</div><div>        Integer i4=Integer.valueOf(123);</div><div>        System.out.println(i3==i4);//true：[-128,127]范围，就获取缓存中的数据</div><div><br/></div><div>        Integer i5=123;//自动装箱底层：Integer.valueOf(123)</div><div>        Integer i6=123;</div><div>        System.out.println(i5==i6);//true</div><div>        System.out.println("--------------");</div><div>        Integer i11=new Integer(250);</div><div>        Integer i21=new Integer(250);</div><div>        System.out.println(i11==i21);//false</div><div><br/></div><div>        Integer i31=Integer.valueOf(250);//250不在[-128,127]之间，就得new一个新的Integer</div><div>        Integer i41=Integer.valueOf(250);</div><div>        System.out.println(i31==i41);//false</div><div><br/></div><div>        Integer i51=250;</div><div>        Integer i61=250;</div><div>        System.out.println(i51==i61);//false</div><div><br/></div><div>        System.out.println(i51.equals(i61));</div><div>    }</div><div>}</div><div><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>包装类的基本操作</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063092,103.846885"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>1、包装类中的常量：</div><div><span>    MAX_VALUE/MIN_VALUE/SIZE（在内存中存储占多少位）/TYPE对应的基本类型</span></div><div><span>2、包装类的构造器，xxx类型的包装类Xxx：（xxx表示八大数据类型）</span></div><div><span><span>    Xxx（xxx value）：接收自己的基本类型值</span><br/></span></div><div><span><span><span>    Xxx（String value）：接收String类型，但是Character除外</span><br/></span></span></div><div><span>    </span>构造器的作用：创建包装类对象</div><div>3、基本类型和包装类型的转换（装箱和拆箱）</div><div><span>    装箱：</span><br/></div><div><span><span>    <span>    Integer i1=new Integer(123);</span></span><br/></span></div><div><span><span><span><span>    <span>    Integer i2=new Integer.valueOf(123)//推荐，带有缓存</span></span><br/></span></span></span></div><div><span>    拆箱</span><br/></div><div><span><span>    <span>    int val=i1.intValue()</span></span><br/></span></div><div><span><span><span>4、String和基本类型之间的转换操作</span></span></span></div><div><span><span><span>    <font color="#ff2600">String和int／Integer之间的转换操作：转换方法必须在String类中或Integer类中</font><br/></span></span></span></div><div><span><span><span><br/></span></span></span></div><div>    <b>把String转换为包装类类型：</b><br/></div><div><span><span><span><span>    方式一：static Xxx valueOf（String str）：把String转换为包装类对象</span><br/></span></span></span></div><div><span><span><span><span><span>    <span>    Integer i1=Integer.valueOf(“123”);</span></span><br/></span></span></span></span></div><div><span><span><span><span><span>    方式二：new Xxx（String str）</span></span></span></span></span></div><div><span><span>    <span>    Integer i2=new Integer(“123”);</span></span><br/></span></div><div><b><span>    </span>把基本数据类型转换为String：</b></div><div><b>       </b> String str=17+””;</div><div>    <b>把包装类对象转换为String</b><br/></div><div><span><span>    <span>    String str=任何对象.toString();</span></span><br/></span></div><div>    <b>把String转换为基本数据类型</b><br/></div><div><span>    <span>    </span></span>Static xxx parseXxx(String s):xxx表示八大数据类型</div><div><span><span>    <span>    String input=“12345</span></span>”<br/></span></div><div><span><span><span><span>    <span>    Int num=Integer.parseInt(input);</span></span><br/></span></span></span></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>装箱和拆箱操作</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063092,103.846885"><b>Map</b></a><br/>
  </td></tr>
</table>
<div><img src="%E7%AC%AC%E4%B9%9D%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/2014071109000485.jpg" height="225" width="661"/>八大基本数据类型的包装类都使用final修饰，都是最终类，都不能被继承<br/></div><div>装箱：把基本数据类型转成对应的包装类对象</div><div>拆箱：把包装类对象转成基本数据类型</div><div><font color="#ff2600">Sun公司在java5开始提供了的自动装箱（Autoboxing）和自动拆箱（AutoUnboxing）功能</font></div><div>自动装箱：可把一个基本数据类型变量直接赋给对应的包装类变量</div><div>自动拆箱：允许把包装类对象直接赋给对应的基本数据类型变量</div><hr/><div><span>    <span>    </span></span>//装箱操作：把一个基本数据类型的值，转换为队形包装类对象</div><div>        //方式一</div><div>        Integer num1=new Integer(17);</div><div>        //方式二</div><div>        Integer num2=Integer.valueOf(17);</div><div><br/></div><div>        //拆箱操作：把包装类对象，转换为对应的基本数据类型变量</div><div>        int num3=num1.intValue();</div><div>在java的即可框架中，只能存储对象，不能存储基本数据类型值</div><div><span>    每次存储到集合中的基本数据都得手动装箱</span><br/></div><div><span><br/></span></div><div>自动装箱和拆箱，也是一个语法糖／编译器级别的新特性</div><div>在底层还是手动装箱和拆箱操作</div><div>到那时：装箱操作使用的是Integer.valueOf的方式，而不是直接new Integer</div><div><hr/>switch支持的数据类型：byte，short，char，int也支持它们对应的包装类，为何？</div><div><span>    在底层，sitich中会对包装类做手动拆箱操作</span></div><div><span><br/></span></div><div>解释Object obj=17;</div><div><span>    1、自动装箱：Integer i=17;</span><br/></div><div><span><span>    2、引用类型的自动转换，把子类对象赋给父类对象：Obect obj=i;</span><br/></span></div><div><span><span><hr/>Object可以接收一切类型的值</span></span></div><div><span><span><span>    Object数组：Object[]该数组可以装一切数据类型</span><br/></span></span></div><div><span><span><span><span>    Object arr={“A”,12,3,14,true}</span><br/></span></span></span></div><hr/><div><span><span><span><span>//演示包装类：装箱和拆箱操纵</span></span></span></span></div><div>public class IntegerDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //装箱操作：把一个基本数据类型的值，转换为队形包装类对象</div><div>        //方式一</div><div>        Integer num1=new Integer(17);</div><div>        //方式二</div><div>        Integer num2=Integer.valueOf(17);</div><div><br/></div><div>        //拆箱操作：把包装类对象，转换为对应的基本数据类型变量</div><div>        int num3=num1.intValue();</div><div>        System.out.println(num1);</div><div>        System.out.println(num2);</div><div>        System.out.println(num3);</div><div>        System.out.println("---------");</div><div>        //自动装箱：可把一个基本数据类型变量直接赋给对应的包装类变量</div><div>        Integer num4=17;</div><div>        //自动拆箱：允许把包装类对象直接赋给对应的基本数据类型变量</div><div>        int num5=num4;</div><div>        System.out.println(num4);</div><div>        System.out.println(num5);</div><div><br/></div><div>        Integer num10=10;</div><div>        switch(num10)</div><div>        {</div><div>            case 1:</div><div>            case 2:</div><div>            default:</div><div>                return;</div><div>        }</div><div><br/></div><div>        Object obj=17;</div><div>    }</div><div>}</div><div><span><span><span><span><br/></span></span></span></span><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>引出基本类型包装类</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063089,103.846910"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>问题1:在面向对象中，“一切皆对象”，现在问题来了，int age=17;请问这age代码哪里有对象，基本类型变量不是对象，此时有矛盾</div><div><br/></div><div>问题2:现在给你一个复杂的十进制数据，请你迅速在程序中转成二进制，八进制，十六进制</div><div><br/></div><div>问题3:现在使用double类型来表示学生成绩，double类型初始值为0.0，但是：你怎么表示一个人缺考和考试得0分</div><div><hr/><font color="#0433ff">上述的问题，就是因为基本数据类型缺少对象，如果需要对象，必须先有类</font></div><div><span>    </span>此时我们可以为每一个基本类型都编写一个对应的包装类，类中包含了该基本类型的一个值</div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>工具类的设计</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063055,103.846811"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>工具类：存放了某一类食物的工具方法的类<br/></div><div><br/></div><div>工具类存放的包：工具包（util，tools，utils，tool），存放工具类</div><div>工具类起名：XxxUtil/XxxUtils/XxxTools/XxxTool，Xxx表示一类食物</div><div><span>    <span>    比如：ArrayUtil,StringUtil,JdbcUtil</span></span><br/></div><div><span><span><hr/>工具类如何设计：工具在开发中其实只需要存在一份即可</span></span></div><div><span><span><span>    1、如果工具方法没有使用static修饰，说明工具方法得使用工具类的对象来调用</span></span></span></div><div><span><span><span><span>    <span>    此时把工具类设计成单例的</span></span><br/></span></span></span></div><div><span><span><span><span><span><span>    2、如果工具方法全部都使用static修饰，说明工具方法只需要使用工具类名调用即可</span><br/></span></span></span></span></span></div><div><span><span><span><span><span><span><span>    <span>    此时必须把工具类的构造器私有化（防止创建工具类对象来调用静态方法）</span></span><br/></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><hr/>一般的首选第二种，简单，在JDK中都使用第二种，<font color="#0433ff">如java.util.Arrays类</font></span></span></span></span></span></span></span></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>单例设计模式</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063041,103.846804"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>设计模式（Design pattern）中；<font color="#0433ff">是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。</font>使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式使软件工程的基石脉络，如同大厦结构一样</div><div><hr/>需求：定义一个数组的工具类(ArrayUtil)，使用单例模式解决</div><div><b>单例设计模式（singleton）</b>：最常用，最简单的设计模式，单例的编写有N中写法</div><div><span>     目的：保证某一个在整个应用中有且只有一个实例（一个类在内存中之存在一个对象）。即所有指向该类型的实例的引用都指向同一块内存空间</span><br/></div><div><b>写单例模式的步骤：</b>单讲饿汉式</div><div><span>    1、必须在该类中自己先创建出一个对象</span><br/></div><div><span><span>    2、私有化自身的构造器，防止外界通过构造器创建新的对象</span></span></div><div><span><span><span>    3、向外暴露一个公共的静态方法用于获取自身的对象</span><br/></span></span></div><hr/><div><span><span><span>class ArrayUtil</span></span></span></div><div>{</div><div>    //1、必须在该类中自己先创建出一个对象</div><div>    private static ArrayUtil instance=new ArrayUtil();</div><div>    // 2、私有化自身的构造器，防止外界通过构造器创建新的对象</div><div>    private ArrayUtil()</div><div>    {</div><div><br/></div><div>    }</div><div>    public static ArrayUtil getInstance(){</div><div>        return instance;</div><div>    }</div><div>    //排序操作</div><div>    public void sort(int[] arr)</div><div>    {</div><div>        System.out.println("排序操作");</div><div>    }</div><div>}</div><div>//单例</div><div>public class Singleton</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        ArrayUtil.getInstance().sort(null);</div><div>    }</div><div>}</div><div><span><span><span><br/></span></span></span><br/></div><div><b><br/></b></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>final变量（常量）</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063066,103.846822"><b>Map</b></a><br/>
  </td></tr>
</table>
<div><span style="font-weight: bold;">final修饰的变量：</span>最终的变量，常量，该变量只能赋值一次，不能再赋值</div><hr/><div>final修饰的变量：只能赋值一次，不能再赋值</div><div>    常量的分类：</div><div>        1、字面量常量（直接给出的数据值）</div><div>        2、定义的final变量<br/></div><hr/><div>1、final变量必须显示地指定初始值，系统不会为final字段初始化</div><div>2、final变量一餐赋予初始值，就不能被重复赋值</div><div>3、常量名规范：常量名符合标识符，单词全部使用大写，如果是多个单词组成，单词间使用下划线隔开</div><div>    Int类型的最大值：final int MAX_VALUE=….;</div><div>    补充概念：<span style="font-weight: bold;">全局静态常量：</span><span style="color: rgb(4, 51, 255);">public static final修饰的变量。直接使用类名调用即可</span></div><hr/><div>面试题：final修饰的引用类型变量到底表示引用类型不饿能改变，还是引用空间中的数据不可改变</div><div>final修饰基本类型变量：表示该变量的值不能改变，既不能用”...”号重新赋值</div><div>final修饰引用类型的变量：表示该变量的引用地址不能变，而不是引用地址里的内容不能变</div><hr/><div>final是唯一可以修饰局部变量的修饰符、局部内部类只能访问final修饰的局部变量</div><div><span style="font-weight: bold;">什么时候使用常量：</span></div><div><span style="font-weight: bold;">    当在程序中，多个地方使用到共同的数据，且数据不会改变，此时我们专门定义全局的常量</span></div><div><span style="font-weight: bold;">    一般的，我们在开发中会专门定义一个常量类，专门来储存常量数据</span><br/></div><hr/><div><img src="%E7%AC%AC%E4%B9%9D%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/u=566483856,3849308616&amp;fm=26&amp;gp=0.jpg" height="239" width="600"/><br/></div><div><span style="font-weight: bold;"><hr/><br/></span></div><div><span style="font-weight: bold;">//final修饰符</span></div><div>class SuperClass</div><div>{</div><div>    public void doWork()</div><div>    {</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><div>class SubClass extends SuperClass</div><div>{</div><div>    public void doWork()</div><div>    {</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><div>public class FinalDemo</div><div>{</div><div>    final static String name="AA";</div><div>    public static void main(String[] args){</div><div>       </div><div>        //name="BB";</div><div>        //System.out.println(name);</div><div>        final Person p=new Person();</div><div>        System.out.println(p.info);</div><div>        p.info="之后的值";</div><div>        System.out.println(p.info);</div><div>    }</div><div>}</div><div><br/></div><div>class Person</div><div>{</div><div>    public String info="最初的值";</div><div><br/>}</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>final类和final方法</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063079,103.846842"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>为什么需要使用final修饰符：</div><div><font color="#ff2600">继承关系最大的弊端就是破坏封装：</font><font color="#0433ff">子类能访问父类的实现细节，而且可以使用方法覆盖的形式修改细节</font></div><div><hr style="color: rgb(4, 51, 255);"/>多个修饰符之间是没有先后关系的。public static final/public final static/final static public </div><div>final本身的含义是“最终的不可变的”，它可以修饰非抽象类，非抽象方法和变量，注意：构造方法不能使用final修饰，因为构造方法不能被继承，肯定是最终的</div><div><span style="font-weight: bold;">final修饰的类：</span>表示最终类，该类不能再有子类（错误: 无法从最终SuperClass进行继承）</div><div><b>final修饰的方法：</b>最终的方法，该方法不能被子类覆盖（错误: SubClass中的doWork()无法覆盖SuperClass中的doWork()）</div><div><span>    什么时候的方法需要final修饰：</span><br/></div><div><span><span>        1、在父类提供的统一的算法骨架，不准子类通过方法覆盖来修改，此时使用final修饰，<font color="#0433ff">模版方法设计模式</font></span><br/></span></div><div><span>    <span>    2、在构造器中调用的方法（初始化方法）初始化方法一般使用final修饰</span></span><br/></div><div><span><span><span>        注意：f<font color="#ff2600">inal修饰的方法，子类可以调用，但是不能覆盖</font></span><br/></span></span></div><div>final修饰的变量：最终的变量，常量，该变量只能赋值一次，不能再赋值</div><div><span>    <span>    final是唯一可以修饰局部变量的修饰符</span></span><br/></div><div><hr/>只要满足以下条件就可以把一个类设计成final类：</div><div>1、某类不是专门为了继承而设计</div><div>2、出于安全考虑，类的实现细节不许改动，不准修改源代码</div><div>3、确信该类不会再被拓展</div><div><b>面试题<font color="#0433ff">：</font></b><font color="#ff2600">列举5个java中内置的使用final修饰的类</font></div><div><br/></div><div>java里final修饰的类很多，比如八大基本数据类型保证类和String等</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>代码块语句</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063067,103.846824"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>什么是代码块：</div><div><span>    在类或者方法中，直接使用{}括起来的一段代码，表示一块代码区域</span><br/></div><div><span><span>    代码块里的变量属于局部变量，只在自己所在区域（前后的{}）内有效</span><br/></span></div><div><span><span><span>根据代码块定义的位置的不同我们又分成三种形式：</span><br/></span></span></div><div><span><span><span>    1、<b>局部代码块</b>：直接定义在方法内部的代码块<br/></span></span></span></div><div><span><span><span><span>    <span>    一般的我们是不会直接使用局部代码块的，只不过我们会结合if，while，for，try等关键字连用，表示一块代码区域</span></span><br/></span></span></span></div><div><span><span><span><span><span>    2、<b>初始化代码块（构造代码块）</b>：直接定义在类中<br/></span></span></span></span></span></div><div><span><span><span><span><span><span>    <span>    每次创建对象都会执行初始化代码块</span></span><br/></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span>        <font color="#0433ff">每次创建对象都会调用构造器，在调用构造器之前，会先执行本类中的初始化代码块</font></span><br/></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span>        通过反编译之后发现：初始化代码块也作为构造器<b>最初的语句</b></span><br/></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><b>        </b>我们一般是不使用初始化代码块的，即使要做初始化操作，我们一般在构造器中进行即可，如果做初始化操作的代码比较多，此时构造器的结构比较混乱，此时专门定义一个方法做初始化操作，再在构造器中调用即可。<br/></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span>    <font color="#0433ff">3、静态代码块：使用static修饰的初始化代码块</font><br/></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    在主方法执行之前执行静态代码块，只执行一次</span></span><br/></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    我们说main方法是程序的入口，为什么静态代码块优先于main方法执行</span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>    —&gt;静态成员随着字节码的加载也加载进JVM，因为方法需要JVM调用</span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>    <span>        <font color="#0433ff">先把字节码加载进JVM，而后JVM再调用main方法</font></span></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>        一般的，我们用来做<font color="#0433ff">对象初始化操作，加载资源，加载配置文件等</font></span><br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><hr/><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><font>//代码块</font></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>class CodeBlockDemo</div><div>{</div><div>  </div><div>    {</div><div>        System.out.println("这是一个初始化代码块");</div><div>    }</div><div>    CodeBlockDemo(){</div><div>        System.out.println("构造器");</div><div>    }</div><div>   static </div><div>    {</div><div>        System.out.println("这是一个初始化代码块");</div><div>    }</div><div>    public static void main(String[] args)</div><div>    {</div><div>        System.out.println("进入主方法");</div><div>        //创建三个CodeBlock对象</div><div>        new CodeBlockDemo();</div><div>        new CodeBlockDemo();</div><div>        new CodeBlockDemo();</div><div>    }</div><div><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><font><br/></font></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>}</div>

<table bgcolor="#D4DDE5" border="0" width="100%">
  <tr><td>
    <h1>多字段不存在多态特征</h1>
    <a href="http://maps.google.com/maps?z=6&amp;q=36.063103,103.846816"><b>Map</b></a><br/>
  </td></tr>
</table>
<div>通过对象调用字段，在<span style="color: rgb(255, 38, 0);">编译时期</span>就已经决定了调用那一块内存空间的数据————&gt;<span style="color: rgb(255, 38, 0);">字段不存在覆盖的概念</span>，在多态时，不能有多态特征（在运行时期体现子类特征）</div><div><br/></div><div><span style="color: rgb(4, 51, 255);">只有方法才有覆盖的概念</span></div><div>当子类和父类存在相同字段的时候，不论修饰符是什么（即使是private），都会在各自的内存空间中储存数据</div><div><hr/></div><div>class SuperClass{</div><div>    public String name="Super.name";</div><div><br/></div><div>    public void doWork(){</div><div>        System.out.println("Super.doWork");</div><div>    }</div><div>}</div><div><br/></div><div>class SubClass extends SuperClass{</div><div>    public String name="Sub.name";</div><div><br/></div><div>    public void doWork(){</div><div>        System.out.println("Sub.doWork");</div><div>    }</div><div>}</div><div>//字段不存在多态特征</div><div>class FieldDemo{</div><div>    public static void main(String[] args){</div><div>        SuperClass clz=new SubClass();</div><div>        clz.doWork();//Sub.doWork</div><div><br/></div><div>        System.out.println(clz.name);//Super.name</div><div>    }</div><div>}</div></body></html>