<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.12.3 (455521)"/><meta name="altitude" content="1531.352905273438"/><meta name="author" content="923435274@qq.com"/><meta name="created" content="2017-07-20 07:19:28 +0000"/><meta name="latitude" content="36.07998040880869"/><meta name="longitude" content="103.8517647377318"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-07-27 02:05:22 +0000"/><title>第七单元笔记</title></head><body><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>判断点和圆的关系</h1><div  /></td></tr></tbody></table><div>练习：判断一个点和圆的关系（在园外，在圆内，在圆上） </div><hr/><div>名词解析法：一般的名词要么事对象，要么是状态</div><div>                                动词：方法</div><hr/><div>成员变量：以m作为前缀<br/></div><div>局部变量：以s作为前缀</div><div><hr/></div><div>//点对象</div><div>class Points{</div><div>    private int x;//横坐标</div><div>    private int y;//纵坐标</div><div><br/></div><div>    Points(int x,int y){</div><div>        this.x=x;</div><div>        this.y=y;</div><div>    }</div><div>    public int getX(){</div><div>        return x;</div><div>    }</div><div>    public int getY(){</div><div>        return y;</div><div>    }</div><div>}</div><div>//圆对象</div><div>class Circle{</div><div>    private int r;//半径</div><div>    Circle(int r){</div><div>        this.r=r;</div><div>    }</div><div>    /*</div><div>        判断点和圆的位置关系</div><div>            参数：需要判断的点对象</div><div>            返回：</div><div>                1表示在圆外</div><div>                0表示在圆上</div><div>                -1示在圆内</div><div>    */</div><div>    int judge(Points p){</div><div>        int xxyy=p.getX()*p.getX()+p.getY()*p.getY();</div><div>        int rr=this.r*this.r;</div><div>        if(xxyy&gt;rr){</div><div>            return 1;</div><div>        }else if(xxyy&lt;rr){</div><div>            return -1;</div><div>        }else{</div><div>            return 0;</div><div>        }</div><div>    }</div><div><br/></div><div>    public int getR(){</div><div>        return r;</div><div>    }</div><div>}</div><div>class PointDemo{</div><div>    public static void main(String[] args){</div><div>        //创建一个点对象（3，4）</div><div>        Points p1=new Points(3,3);</div><div>        //创建一个半径为5的圆对象</div><div>        Circle c1=new Circle(5);</div><div><br/></div><div>        //判断</div><div>        int ret=c1.judge(p1);</div><div>        System.out.println(ret);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>构造器和setter方法选用</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079947,103.851716">Map</a></div><div  /></td></tr></tbody></table><div>创建对象冰给对象设置初始值有两种方式：</div><div>    方式1、先通过无参数构造器创建出一个对象，再通过调用对应的setter 方法</div><div>        User u1=new User();<br/></div><div>        u1.setName(“Lucy”);</div><div>        u1.setAge(18);</div><div>    方法2、直接调用带参数的构造器，创建出来的对象，就有了初始值<br/></div><div>        User u1=new User("张三",18);</div><hr/><div>通过构造器和通过setter方法都可以完成相同的功能</div><div>给对象设置数据：</div><div>        1、setter注入（属性注入）</div><div>        2、构造注入<br/></div><hr/><div>如何选择：</div><div>    1、如果存在带参数的构造器用方式2比较简洁<br/></div><div>    2、如果在构建对象的时候需要初始化多个数据，如果使用方式2，那么构造器得提供N个参数，参数过大不直观，此时方式1简单明了<br/></div><div>    3、圆对象，圆对象必须根据半径来确定对象<br/></div><div>        就应该在构建圆对象的时候就要却确定半径值<br/></div><div>        有时候需要根据数据来构建对象，此时优先选用构造器方式<br/></div><hr/><div>其他时候任选</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>this关键字的使用</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079940,103.851710">Map</a></div><div  /></td></tr></tbody></table><div>使用this：</div><div>    1、解决成员变量和与参数（局部变量）之间的二义性</div><div>    2、同类中实例方法间相互调用（此时可以省略this，但是不建议省略）<br/></div><div>    3、将this作为参数传递给另一个方法<br/></div><div>    4、将this作为方法的返回值（链式方法编程）<br/></div><div>    5、构造器重载的互调<br/></div><div>    6、static不能喝this一起使用<br/></div><div>        当字节码被加载进JVM，static成员就已经存在了，但是此时对象还没有存在，没有对象就没有this<br/></div><div><img src="%E7%AC%AC%E4%B8%83%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/%E6%9C%AA%E5%91%BD%E5%90%8D.jpeg" height="506" width="586"/><br/></div><div>上图的代码，没问题：</div><div>    但是：存在一些问题</div><div>        1、代码功能重复？this.name=name;<br/></div><div>        2、代码重复回导致代码维护性低</div><div>            解决方案：构造器互调，但是只能调用一次其他构造器，并且调用的方法应该在构造器中的最开始的一行<br/></div><div>        推论：构造器中只能调用一个重载的构造器<br/></div><div>注意：当多个构造器时，或者多个方法重载时，一般的我们是少参数的调用多参数的</div><hr/><div>参数越多，该方法考虑的未知的因素越多，也就是说功能更强大。</div><div>    </div><div>    </div><hr/><div><br/></div><div>//用户信息类</div><div>class User{</div><div>    private String name;//名称</div><div>    private int age;//年龄</div><div>    </div><div>    //默认构造器</div><div>    User(){</div><div>        System.out.println("----");</div><div>    }</div><div>    //创建对象，初始化name</div><div>    User(String name){</div><div>        this();//调用无参数构造器</div><div>        this.name=name;</div><div>    }</div><div>    //创建对象，初始化name和age</div><div>    User(String name,int age){</div><div>        this(name);//调用了有一个参数的构造器</div><div>        this.age=age;</div><div>    }</div><div>    </div><div>    public String getName(){</div><div>        return name;//返回name字段的值</div><div>    }</div><div>    public void setName(String name){</div><div>        this.name=name;//表示把调用者传递的n参数的值赋给name字段</div><div>    }</div><div><br/></div><div>    public int getAge(){</div><div>        return age;</div><div>    }</div><div>    public void setAge(int age){</div><div>        this.age=age;</div><div>    }</div><div><br/></div><div>    //打印当前对象的name和age</div><div>    public void show(){</div><div>        System.out.println(this.name+","+this.age);</div><div>    }</div><div>}</div><div>//this关键字</div><div>class ThisDemo{</div><div>    public static void main(String[] args){</div><div>        User u1=new User("张三",18);</div><div>        u1.show();</div><div>        /*</div><div>        User u1=new User();</div><div>        u1.setName("Lucy");</div><div>        u1.setAge(18);</div><div>        </div><div>        User u2=new User();</div><div>        u2.setName("Will");</div><div>        u2.setAge(17);</div><div><br/></div><div>        u1.show();//显示出u1自己的name和age</div><div>        u2.show();//显示出u1自己的name和age</div><div>        */</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>引出/理解this关键字</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079988,103.851739">Map</a></div><div  /></td></tr></tbody></table><div>什么是this：</div><div>    表示当前对象，什么又是当前对象</div><div>    This主要存在于两个位置：<br/></div><div>        构造器中：就表示当前创建的对象<br/></div><div>        方法中：哪一个对象调用this所在的方法，那么此时this就表示哪一个对象<br/></div><div>    当一个对象创建之后，JVM会分配一个引用自身的引用</div><hr/><div>//用户信息类</div><div>class User{</div><div>    private String name;//名称</div><div>    private int age;//年龄</div><div>    </div><div>    User(){</div><div>        System.out.println(this);</div><div>    }</div><div>    </div><div>    public String getName(){</div><div>        return name;//返回name字段的值</div><div>    }</div><div>    public void setName(String name){</div><div>        this.name=name;//表示把调用者传递的n参数的值赋给name字段</div><div>    }</div><div><br/></div><div>    public int getAge(){</div><div>        return age;</div><div>    }</div><div>    public void setAge(int age){</div><div>        this.age=age;</div><div>    }</div><div><br/></div><div>    //打印当前对象的name和age</div><div>    public void show(){</div><div>        System.out.println(this.name+","+this.age);</div><div>    }</div><div>}</div><div>//this关键字</div><div>class ThisDemo{</div><div>    public static void main(String[] args){</div><div>        User u1=new User();</div><div>        u1.setName("Lucy");</div><div>        u1.setAge(18);</div><div>        </div><div>        User u2=new User();</div><div>        u2.setName("Will");</div><div>        u2.setAge(17);</div><div><br/></div><div>        u1.show();//显示出u1自己的name和age</div><div>        u2.show();//显示出u1自己的name和age</div><div>    }</div><div>}</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>JavaBean规范（简述）</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079950,103.851682">Map</a></div><div  /></td></tr></tbody></table><div>JavaBean是一种JAVA语言写成的可重用组件（类）</div><div>必须遵循一定的规范：</div><div>    1、类必须用public修饰</div><div>    2、必须保证有公共屋参数构造器，即使手动提供了带参数的构造器，也得提供无参数构造器<br/></div><div>    3、包含了属性的操作手段（给属性复制，获取属性值）<br/></div><div>分类：</div><div>    1、复杂：UI，比如Button，Panel／Window类</div><div>    2、简单：domain，service组件，封装数据，操作数据库，逻辑运算等<br/></div><div>        （封装有字段，并提供getter／setter）<br/></div><div>成员：</div><div>    1、方法：Method</div><div>    2、时间：event<br/></div><div>    3、属性：property<br/></div><hr/><div>属性：</div><div>    1、attribute：表示状态，java中没有该概念，很多人把字段（Field）称之为属性（attribute），不要把成员变量叫做属性<br/></div><div>    2、property：表示状态，但不是字段，是属性的操作方法（getter／setter）决定的，框架中使用的大多是属性</div><hr/><div>我们讲完封装后，说应该把对象中的信息隐藏起来（把类中的字段都用private修饰起来，其他类不能直接访问）</div><div>为了能让外界（其他类）访问到本类中的私有的字段，我们专门提供getter以及setter方法</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">字段： private String name;</span></div><hr/><div>getter方法：仅仅用于获取某一个字段存储的值</div><div>//去掉get，把首字母小写，得到name，此时name才是属性</div><div>pubic String getName(){</div><div>    return name;//返回那么字段存储的值</div><div>}</div><div>如果操作的字段是boolean类型的，此时不应该叫做getter方法，而是is方法，把getName变成isName</div><hr/><div>setter方法：仅仅用于给某一个字段设置需要的值</div><div>public void setName(String n){</div><div>    name=n；//把传过来的n参数的值，存储到那么字段中</div><div>}</div><div>每一个字段都得提供getter／setter，以后使用Eclipse工具之后getter／setter都是自动生成的</div><hr/><div>在JavaBean中有属性这个概念，只有标准情况下字段名和属性名才相同：</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>权限访问修饰符</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.062982,103.846688">Map</a></div><div  /></td></tr></tbody></table><div>封装就是让有些类看不到另一些类里面做了什么事情，所以java提供了访问权限修饰符来规定在一个类里面能看到什么，能暴露什么</div><hr/><div>访问权限控制：</div><div>private：表示私有的，它表示类访问权限，只能在本类中访问，离开本类后，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">就不能直接访问</span></div><div>不写（缺省）：表示包私有，表示包访问权限，访问者的包和当前定义类的包相同才能访问</div><div>protected：表示子类访问权限，同包中的可以访问，即使不同包，但是有继承关系，也可以访问</div><div>public：表示全局的，可以公共访问权限，若某一个字段／方法，使用了public修饰，则可以在当前项目中任何地方访问<img src="%E7%AC%AC%E4%B8%83%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/105409175.jpg" height="232" width="923"/><br/></div><hr/><div>一般的：字段都使用private修饰，表达隐藏，为了安全性</div><div>拥有实现细节的方法，一般使用private修饰，不希望外界（调用者）看到该方法的实现细节</div><div>一般的方法使用public修饰，供外界直接调用</div><div>一般不用缺省，即使要使用，也仅仅是暴露给同包中的其他类</div><div>protected：一般，在继承关系中，父类需要把一个方法只暴露给子类</div><hr/><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>理解封装思想</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079943,103.851679">Map</a></div><div  /></td></tr></tbody></table><div>什么是封装？（面向对象三大特征之一）</div><div>1、把对象的状态和行为看成一个统一的整体，将二者放在一个独立的模块中（类）</div><div>2、“信息隐藏”，把不需要让外界知道的信息隐藏起来，尽可能隐藏对象功能实现细节，向外暴露方法，保证外界安全访问功能；把所有字段使用private私有化，不许外部访问，把方法使用public修饰，允许外界访问</div><div>                把所有数据信息隐藏起来，尽可能隐藏多的功能，只向外暴露便携的方法，以供调用</div><div>封装的好处：</div><div>1、使调用者正确，方便地使用系统功能，防止调用者随意修改系统属性</div><div>2、提高组件的重用性</div><div>3、达到组件之间的低耦合性（当某一个模块实现发生变化时，只要对外暴露的接口不变，就不会影响到其他模块）</div><div>通过什么来实现隐藏和暴露功能呢？</div><hr/><div>class Person{</div><div>    String name;</div><div>    private int age;</div><div><br/></div><div>    //setter方法：专门公寓给对象设置age数据，并把传过来的数据保存在对象中</div><div>    void setAge(int a){</div><div>        if(a&lt;0){</div><div>            System.out.println("你傻啊，年龄不能为负数");</div><div>            return;//结束方法</div><div>        }</div><div>        age=a;//把a的值赋给age字段</div><div>    }</div><div>}</div><div>//演示封装</div><div>class PersonDemo{</div><div>    public static void main(String[] args){</div><div>        //创建一个Person对象，设置年龄</div><div>        Person p=new Person();</div><div>        p.name="Will";</div><div>        p.setAge(-17);</div><div><br/></div><div><br/></div><div>        //System.out.println(p.name+","+p.age);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>static import（静态导入）</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079981,103.851757">Map</a></div><div  /></td></tr></tbody></table><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注意：编译器会默认找java.lang包下的类，但是却不会去找java.lang的子包下的类</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    比如：java.lang.reflect.Method类</span><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    此时我们也得使用import java.lang.reflect.Method</span><br/></div><div>int[] arr=new int[]{1,-2,3,89,5,6};</div><div>        //打印数组</div><div>        String ret=Arrays.toString(arr);</div><div>        //排序</div><div>        java.util.Arrays.sort(arr);</div><div>        //打印</div><div>        ret=Arrays.toString(arr);</div><div>在上述代码中，每次使用Arrays类中的静态方法，即使我们使用了import语句，但是每次都需要使用Arrays类名去调用静态方法，我期望：我能把Arrays类中的静态成员一样调用</div><div><br/></div><div>解决方案：</div><div>    语法格式：</div><div>    import static 类的全限定名.该类中的static成员名;<br/></div><div><br/></div><div>    import static 类的全限定名称.*;此时的*表示当前类的任何使用到的静态成员<br/></div><hr/><div>通过反编译工具，其实所谓的静态导入也是一个语法糖／编译器级别的新特性</div><div>在实际开发中，我们不使用静态导入，因为如此，分不清某一个静态方法或字段来源于哪一个类</div><div>Eclipse工具，当格式化代码的时候，就自动取消了所有的静态导入，变成使用类名调用</div><hr/><div>//静态导入</div><div>import java.util.Arrays;</div><div>//把java.util.Arrays类中的静态方法sort导入到StaticImportDemo类中</div><div>import static java.util.Arrays.sort;</div><div>import static java.util.Arrays.binarySearch;</div><div>public class StaticImportDemo{</div><div>    public static void main(String[] args){</div><div>        int[] arr=new int[]{1,-2,3,89,5,6};</div><div>        //打印数组</div><div>        String ret=Arrays.toString(arr);</div><div>        //排序</div><div>        sort(arr);</div><div>        //打印</div><div>        ret=Arrays.toString(arr);</div><div><br/></div><div>        binarySearch(arr,3);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>improt关键字</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.049979,103.814423">Map</a></div><div  /></td></tr></tbody></table><div>当A类和B类不在同一个包内，若A类需要使用到B类，就带让A类中引入B类</div><div>Arrays类的全限定名是：java.util.Arrays</div><hr/><div>没有使用import之前，操作不在同一个包中的类，得使用全限定名操作。</div><div>    解决方案：使用import语句，直接把某个包下的类导入到当前文件中</div><div>    语法格式：import 需要导入类的全限定名;</div><div>    此后，在本java文件中，只需要使用类的简单名称即可</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">编译会自动区寻找java.lang包中去寻找使用到的类，比如String，System，所以它们不需要导入</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">推论：非lang包中的都需要导入</span></div><div>import java.util.Arrays;</div><div>import java.util.Set;</div><div>import java.util.List;</div><div>上述代码，表示分别引入了java.util包下的Arrays类，Set类，List类</div><div>问题：如果我们还需要继续引入java.util包中其他的，我们还得提供N个import语句</div><div>解决方案：使用通配符（*）</div><div>import 类的全限定名;    只能导入某一个类</div><div>import 包名.子包名.*;    引入该包下的所有的在当前文件中使用到的类</div><div>Import java.util.*;    此时的*表示类名</div><div>    在Eclipse工具中，即使我们使用了通配符*，在格式化代码的时候还是N条import语句<br/></div><hr/><div>import java.util.*;</div><div>public class ImportDemo{</div><div>    public static void main(String[] args){</div><div>        int[] arr=new int[]{1,-2,3,89,5,6};</div><div>        //打印数组</div><div>        String ret=Arrays.toString(arr);</div><div>        //排序</div><div>        java.util.Arrays.sort(arr);</div><div>        //打印</div><div>        ret=Arrays.toString(arr);</div><div>        System.out.print(ret);</div><div><br/></div><div>        java.util.Set s;</div><div>        java.util.List l;</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>packa最佳实践</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.050027,103.814467">Map</a></div><div  /></td></tr></tbody></table><div>1、包名如何定义：自定义定包名不能以java.打头，因为java的安全机制会检查这个问题</div><div>    包名必须遵循标志符规范，全部小写</div><div>    企业开发中，包名采用公司域名倒写</div><div>            小码哥域名—&gt;520it.com—&gt;此时520it不符合标识符规范，我们可以使用下划线（com_520it）</div><div>            在安卓中如果package中使用了下划线，则不能部署到模拟器上，此时我们也可以使用一个字母来代替下划线。比如：package com.m520it;  package com.a520it</div><div>———&gt;</div><div>格式：package 域名倒写.模块名称.组件名称;</div><div>    package com_520it.pss.util;————&gt;进销存储模块中存储工具类的包</div><div><br/></div><div>2、类的名称</div><div>    类名有两个名称：</div><div>        1、类的简单名称：        定义类的名称</div><div>        2、类的全限定名称：        包名.类名; com_520it.PackageDemo</div><div>3、在开发中，都是先有package而后在package中再定义类</div><hr/><div>JDK中的包名</div><div><img src="%E7%AC%AC%E4%B8%83%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/f61a8da0b13a111dcee2373586b61d39.png" height="438" width="760"/><br/></div><hr/><div>package abc;</div><div>public class PackageDemo{</div><div>    public static void main(String[] args){</div><div>        System.out.println("Hello");</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>package关键字</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.049977,103.814417">Map</a></div><div  /></td></tr></tbody></table><div>在开发中我们存在着几百上千个java文件，如果所有的java文件都在一个目录中，管理起来也很痛苦，此时我们可以使用生活中的解决方案，不过此时在java中我们把这个特殊的文件夹称之为包（package）</div><div>关键字：package，专门用来给java文件设置包名</div><div>语法格式：</div><div>        package 包名.子包名.子子包名;</div><div>必须把该语句作为java文件中并且是第一行代码，在所有代码之前</div><div>此时编译命令：javac -d . java文件.java</div><div>如果此时Hello.java文件中没有使用package语句表示在当前目录中生成字节码文件</div><div>如果此时Hello.java文件中使用了package语句，此时表示在当前目录中先生成包名，再在包中生成字节码文件</div><div>运行命令：java 包名.类名;</div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>变量的生命周期</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.049967,103.814403">Map</a></div><div  /></td></tr></tbody></table><div>变量的作用域决定了变量的生命周期，作用域不同，生命周期就不同</div><div>变量的生命周期指的是一个变量被创建并分配内存空间，到该变量被销毁并清除其所占内存空间的过程</div><div><img src="%E7%AC%AC%E4%B8%83%E5%8D%95%E5%85%83%E7%AC%94%E8%AE%B0.resources/%E6%9C%AA%E5%91%BD%E5%90%8D_1.jpeg" height="138" width="1950"/><br/></div><div>变量的定义和选择：</div><div>1、考虑变量的生存时间，会影响内存的开销</div><div>2、扩大变量的作用域，不利于提高程序的高内聚</div><div><br/></div><div>开发中应该尽量缩小变量的作用范围，如此在内存中停留时间越短，性能也就越高</div><div>不要动不动就使用static修饰，一般的定义工具方法的时候，static方法需要访问的变量，该变量属于类型，此时才使用static修饰</div><div>也不要动不动就使用成员变量，因为存在着线程不安全的情况，能使用局部变量，尽量使用局部变量</div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>变量分类-作用域-初始值</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079966,103.851803">Map</a></div><div  /></td></tr></tbody></table><div>定义变量的语法：    </div><div>    数据类型 变量名=值;</div><hr/><div>变量根据在类中定义位置的不同，分成两大类：</div><div>成员变量：全局变量／字段（Field），不要称之为属性（错误），直接定义在类中，方法外面</div><div>                    1、类成员变量：使用static修饰的字段</div><div>                    2、实例成员变量：没有使用static修饰的字段<br/></div><div>局部变量：变量除了成员变量，其他的都是局部变量</div><div>                    1、方法内部的变量</div><div>                    2、方法的形参</div><div>                    3、代码块中的变量，一对花括号称之为代码块</div><hr/><div>变量的初始值：初始化彩绘在内存中开辟空间</div><div>成员变量：默认是有初始值的</div><div>局部变量：没有初始值，所以必须先初始化，才能使用</div><hr/><div>变量的作用域：</div><div>    变量根据定义的位置不同，也决定了各自的作用域也是不同的，看变量所在的那对{}</div><div>成员变量：在整个类中都有效</div><div>局部变量：从开始定义的位置开始，到紧跟着结束的花括号为止</div><hr/><div>成员变量可以先使用后定义，局部变量必须先定义而后才能使用</div><div><br/></div><div><br/></div></body></html>