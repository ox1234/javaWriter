<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.12.3 (455521)"/><meta name="altitude" content="1530.712768554688"/><meta name="author" content="923435274@qq.com"/><meta name="created" content="2017-08-02 10:28:04 +0000"/><meta name="latitude" content="36.07996583960486"/><meta name="longitude" content="103.8517524291176"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-08-14 04:02:11 +0000"/><title>第十单元笔记</title></head><body><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>枚举的操作细节</h1><div  /></td></tr></tbody></table><div>1、枚举中都是全局公共的静态常量，可以直接使用枚举类名调用</div><div>    Weekday day=Weekday.SATURDAY;</div><div>2、因为java.lang.Enum类是所有枚举的父类，所以所有的枚举对象可以调用Enum类的方法</div><div>    String name=枚举对象.name();//返回枚举对象的常量名称</div><div>    int ordinal=枚举对象.ordinal();//返回枚举对象的序号，从0开始</div><div>3、由编译器生成的枚举类的静态方法：</div><div>    枚举类型[] values();</div><div>    Weekday[] ws=Weekday.values();//返回当前枚举类型的所有常量，使用一个数组封装起来</div><div>    枚举类型 valueOf(String name);</div><div>    Weekday.valueOf("MONDAY”);//把一个指定名称的字符串转换为当前枚举类中同名的常量</div><div>4、从java5开始出现枚举，switch也支持操作枚举</div><div>    switch只支持int类型，支持枚举是因为底层使用的是枚举对象的ordinal，而ordinal的类型依然是                                  </div><div>int类型</div><hr/><div>枚举主要用来表示事物的固定类型</div><hr/><div>枚举的单例模式：</div><div>在《efective java》中提到建议使用枚举来做单例模式，而且很安全，即使使用反射也不能创建对象</div><hr/><div>enum Weekday</div><div>{</div><div>    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;</div><div>}</div><div>class Employee</div><div>{</div><div>    private Weekday restday;//一周的哪一天休息</div><div><br/></div><div>    public Weekday getRestday()</div><div>    {</div><div>        return restday;</div><div>    }</div><div>    public void setRestday(Weekday restday)</div><div>    {</div><div>        this.restday=restday;</div><div>    }</div><div>}</div><div><br/></div><div>//枚举的引入</div><div>public class EnumDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //创建一个员工对象，并设置哪一天休息</div><div>        Employee e=new Employee();</div><div>        e.setRestday(Weekday.WEDNESDAY);//周三休息</div><div>        //-----------------------</div><div>        </div><div>        Weekday restday=e.getRestday();</div><div>        if(restday==Weekday.SATURDAY||restday==Weekday.SUNDAY)</div><div>        {</div><div>            System.out.println("他周末休息");</div><div>        }</div><div>        else</div><div>        {</div><div>            System.out.println("周一到周五之间休息");</div><div>        }</div><div>        </div><div>        //new Weekday</div><div>        System.out.println(Weekday.SUNDAY);</div><div>        System.out.println(Weekday.SUNDAY.name());</div><div>        System.out.println(Weekday.SUNDAY.ordinal());</div><div><br/></div><div>        System.out.println(Weekday.valueOf("MONDAY"));</div><div><br/></div><div>        Weekday[] ws=Weekday.values();</div><div>        /*</div><div>        for(Weekday day:ws)</div><div>        {</div><div>            System.out.println(day);</div><div>        }</div><div>        */</div><div>        switch(Weekday.SUNDAY)</div><div>        {</div><div>            case MONDAY;break;</div><div>            case TUESDAY;break;</div><div>            case WEDNESDAY;break;</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>枚举的定义和特点以及底层分析</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079969,103.851767">Map</a></div><div  /></td></tr></tbody></table><div>枚举是从java5开始提供的一种新的数据类型，是一个特殊的类，就是固定的多个常量对象的集合</div><div>定义格式：[修饰符] <span style="color: rgb(4, 51, 255);">enum</span> 枚举类名</div><div>{</div><div>        常量A，常量B ，常量C;</div><div>}</div><hr/><div>我们自定义的枚举类型，在编译（在底层）都是直接继承于java.lang.Enum类的，Enum是所有枚举类的父类</div><hr/><div>枚举类的特点：</div><div>1、枚举的直接父类是java.lang.Enum，但是不能显示继承Enum</div><div>2、枚举就相当于一个类，可以定义构造方法，成员变量，普通方法和抽象方法</div><div>3、默认私有的构造方法，即使不写访问也是private（假的构造器，底层没有无参数构造器）</div><div>4、每个实例分别用一个全局常量表示，枚举类的对象是固定的，实例个数有限，不能使用new</div><div>5、枚举实例必须位于枚举体中的最开始部分，枚举实例列表之后要有分号和其他成员相分隔</div><div>6、枚举实例后有花括号时，该实例时枚举类的匿名内部类对象</div><hr/><div>//定义一个星期几的常量类</div><div>/*</div><div>class Weekday</div><div>{</div><div>    private Weekday(){}</div><div>    public static final Weekday MONDAY=new Weekday();</div><div>    public static final Weekday TUESDAY=new Weekday();</div><div>    public static final Weekday WEDNESDAY=new Weekday();</div><div>    public static final Weekday THURSDAY=new Weekday();</div><div>    public static final Weekday FRIDAY=new Weekday();</div><div>    public static final Weekday SATURDAY=new Weekday();</div><div>    public static final Weekday SUNDAY=new Weekday();</div><div>}</div><div>*/</div><div>enum Weekday</div><div>{</div><div>    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;</div><div>}</div><div>class Employee</div><div>{</div><div>    private Weekday restday;//一周的哪一天休息</div><div><br/></div><div>    public Weekday getRestday()</div><div>    {</div><div>        return restday;</div><div>    }</div><div>    public void setRestday(Weekday restday)</div><div>    {</div><div>        this.restday=restday;</div><div>    }</div><div>}</div><div><br/></div><div>//枚举的引入</div><div>public class Hello</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //创建一个员工对象，并设置哪一天休息</div><div>        Employee e=new Employee();</div><div>        e.setRestday(Weekday.WEDNESDAY);//周三休息</div><div>        //-----------------------</div><div>        </div><div>        Weekday restday=e.getRestday();</div><div>        if(restday==Weekday.SATURDAY||restday==Weekday.SUNDAY)</div><div>        {</div><div>            System.out.println("他周末休息");</div><div>        }</div><div>        else</div><div>        {</div><div>            System.out.println("周一到周五之间休息");</div><div>        }</div><div>        </div><div>    }</div><div>}</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>枚举的引入和模拟</h1><div  /></td></tr></tbody></table><div>需求：定义一个Employee（员工），使用一个变量restday来表示那一天休息（一周的哪一天）</div><hr/><div>//定义一个星期几的常量类</div><div>class Weekday</div><div>{</div><div>    public static final int MONDAY=1;</div><div>    public static final int TUESDAY=2;</div><div>    public static final int WEDNESDAY=3;</div><div>    public static final int THURSDAY=4;</div><div>    public static final int FRIDAY=5;</div><div>    public static final int SATURDAY=6;</div><div>    public static final int SUNDAY=7;</div><div>}</div><div>class Employee</div><div>{</div><div>    private int restday;//一周的哪一天休息</div><div><br/></div><div>    public int getRestday()</div><div>    {</div><div>        return restday;</div><div>    }</div><div>    public void setRestday(int restday)</div><div>    {</div><div>        this.restday=restday;</div><div>    }</div><div>}</div><div><br/></div><div>//枚举的引入</div><div>public class Hello</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //创建一个员工对象，并设置哪一天休息</div><div>        Employee e=new Employee();</div><div>        e.setRestday(Weekday.WEDNESDAY);//周三休息</div><div>        //-----------------------</div><div>        int restday=e.getRestday();</div><div>        if(restday==6||restday==7)</div><div>        {</div><div>            System.out.println("他周末休息");</div><div>        }</div><div>        else</div><div>        {</div><div>            System.out.println("周一到周五之间休息");</div><div>        }</div><div>    }</div><div>}</div><hr/><div>存在的问题：</div><div>    1、类型不安全，可以设置非[1,7]之间的数</div><div>    2、业务含义不明确，设置1表示周几（周一还是周日）</div><hr/><div>解决方案</div><div>    专门使用一个类Weekday来表示周一到周日，，使用7个常量表示</div><div><span style="color: rgb(4, 51, 255);">class Weekday</span></div><div><span style="color: rgb(4, 51, 255);">{</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int MONDAY=1;</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int TUESDAY=2;</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int WEDNESDAY=3;</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int THURSDAY=4;</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int FRIDAY=5;</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int SATURDAY=6;</span></div><div><span style="color: rgb(4, 51, 255);">    public static final int SUNDAY=7;</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div>此时调用代码：</div><div>       <span style="color: rgb(4, 51, 255);"> </span><span style="color: rgb(4, 51, 255);">//创建一个员工对象，并设置哪一天休息</span></div><div><span style="color: rgb(4, 51, 255);">        Employee e=new Employee();</span></div><div><span style="color: rgb(4, 51, 255);">        e.setRestday(Weekday.WEDNESDAY);//周三休息</span></div><div><br/></div><div>此时业务含义很明确，因为Weekday.WENDNESDAY就表示周三的意思</div><div>但是，因为在Employee中的restday的类型是int类型，我们依然可以随意设置int类型的数据</div><div><span style="color: rgb(255, 38, 0);">所以，还是没有解决数据类型不安全的问题</span></div><hr/><div>因为int类型不安全，我们把休息日使用一个对象类型来表示，并固定该休息日的值只能是周一到周日，构造器私有化，防止外界创建新的对象</div><div><span style="color: rgb(4, 51, 255);">class Weekday</span></div><div><span style="color: rgb(4, 51, 255);">{</span></div><div><span style="color: rgb(4, 51, 255);">    private Weekday(){}</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday MONDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday TUESDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday WEDNESDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday THURSDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday FRIDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday SATURDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">    public static final Weekday SUNDAY=new Weekday();</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div>此时调用代码：</div><div>    <span style="color: rgb(4, 51, 255);">    </span><span style="color: rgb(4, 51, 255);">//创建一个员工对象，并设置哪一天休息</span></div><div><span style="color: rgb(4, 51, 255);">        Employee e=new Employee();</span></div><div><span style="color: rgb(4, 51, 255);">        e.setRestday(Weekday.SUNDAY);//周三休息</span></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>匿名内部类</h1><div  /></td></tr></tbody></table><div>匿名内部类：一个没有名称的局部内部类，适合只使用一次的类</div><div>在开发中经常有这样的类，只需要定义一次，使用一次就可以丢弃了，此时，不应该定义在一个文件中</div><div>在javaSE／Android的事件处理中：不同的按钮点击以后，应该有不同的响应操作，首选使用匿名内部类</div><div>特点：</div><div>1、<span style="color: rgb(255, 38, 0);">匿名内部类本身没有构造器，但是会调用父类构造器</span></div><div>2、匿名类尽管没有构造器，但是可以在匿名类中提供一段实例化代码块，JVM在调用父类构造器后，会执行该段代码块</div><div>3、内部类处理可以继承之外，还可以实现接口</div><div>格式：</div><div>new 父类构造器[实参列表] 或 接口()</div><div>{</div><div>    //匿名内部类的类体部分</div><div>}</div><div>注意：匿名内部类必须继承一个父类或者实现一个接口，但最多只能一个父类或实现一个接口</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>局部内部类</h1><div  /></td></tr></tbody></table><div>局部内部类：</div><div>在方法中定义的内部类，其可见范围是当前方法，和局部变量是一个级别</div><div>特点：</div><div>1、不能使用public，private，protected，static修饰</div><div>2、局部内部类只能在当前方法中使用</div><div>3、局部内部类和实例内部类一样，不能包含静态成员</div><div>4、局部内部类和实例内部类，可以访问外部类的全部信息</div><div>5、<span style="color: rgb(255, 38, 0);">局部内部类访问的局部变量必须使用final修饰（在java8中自动隐式加上final，但是依然是常量，不能改变值</span></div><div><br/></div><div><span style="color: rgb(255, 38, 0);">原因：如果当前方法不是main方法，那么当前方法调用完毕以后，当前方法的栈帧被销毁，方法内部的局部变量的空间全部销毁</span></div><div>    而局部内部类是定义在方法中的，而且在方法中会创建局部内部类的对象，而局部内部类会去访问局部变量，当前方法被销毁的时候，对象还在堆内存，依然存在对局部变量的引用，但是方法被销毁的时候局部变量已经被销毁了</div><div>    此时出现：在堆内存中，一个对象引用着一个不存在的数据，为了避免该问题，我们使用final来修饰局部变量，从而变成常量，永驻内存空间，即使方法被销毁了，该局部变量仍然在内存中</div><hr/><div>//局部内部类</div><div>class LocalInnerDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //局部内部类</div><div>        System.out.println("Hello World");</div><div>        int age=17;</div><div>        class Inner</div><div>        {</div><div>            String info="INFO";</div><div>            public void test()</div><div>            {</div><div>                //System.out.println(name);//可以直接访问外部类的成员变量</div><div>                System.out.println(info);</div><div>            }</div><div>        }</div><div>        new Inner().test();</div><div>    }</div><div>}</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>实例内部类和静态内部类分析</h1><div  /></td></tr></tbody></table><div>外部类的访问修饰符，要么使用public，要么就缺省</div><div>内部类看作是外部类的一个成员，好比字段，那么内部类可以<span style="color: rgb(4, 51, 255);">使用public／缺省／protected／private修饰</span>，还可以使用static修饰</div><hr/><div>实例内部类：</div><div>没有使用static修饰内部类，说明内部类属于外部类的对象，不属于外部类本身</div><div>特点：</div><div>1、创建实例内部类前，必须存在外部类对象，通过外部类对象创建内部类对象（<span style="color: rgb(255, 38, 0);">当存在内部类对象时，一定存在外部类对象</span>）</div><div>2、实例内部类的实例自动持有外部类的实例的引用过，内部类可以直接访问外部类成员</div><div>3、外部类中u 嗯那个直接访问内部类的成员，必须通过内部类的实例去访问</div><div>4、实例内部类中不能定义静态成员，只能定义实例成员</div><div>5、如果实例内部类和外部类存在同名的字段或方法abc，那么在内部类中：</div><div>    this.abc表示访问内部类成员</div><div>    外部类.this.abc表示访问外部成员</div><hr/><div>静态内部类：</div><div>使用static修饰的内部类</div><div>特点：</div><div>1、静态内部类的实例不会自动持有外部类的特定实例的引用，在创建呃你不累的实例时，不必创建外部类的实例</div><div>2、静态内部类可以直接访问外部类的静态成员，如果访问外部类的实例成员，必须通过外部类的实例去访问</div><div>3、在静态内部类中可以定义静态成员和实例成员</div><div>4、测试类可以通过完整的类名直接访问静态内部类的静态成员</div><hr/><div>对于每个内部类来说：java编译器会生成独立的class文件</div><div><span style="font-weight: bold;">成员内部类</span>：外部类名$内部类名字</div><div><span style="font-weight: bold;">局部内部类</span>：外部类名$数字$内部类名称</div><div><span style="font-weight: bold;">匿名内部类</span>：外部类名$数字</div><hr/><div>//外部类</div><div>class Outter</div><div>{</div><div>    String name="Outter.name";</div><div>    static String name2="name2";</div><div>    public void ooxx()</div><div>    {</div><div>        System.out.println(new Inner().age);</div><div>    }</div><div>    //实例内部类</div><div>    static class Inner</div><div>    {</div><div>        String name="Inner.name";</div><div>        static int age=17;</div><div>        public void test()</div><div>        {</div><div>            String name="local.name";</div><div>            System.out.println(new Outter().name2);</div><div>        }</div><div>    }</div><div>}</div><div>//演示实例内部类</div><div>public class InnerDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        Outter.Inner in=new Outter.Inner();</div><div>        in.test();</div><div>        System.out.println(Outter.Inner.age);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>内部类概述</h1><div  /></td></tr></tbody></table><div>内部类：定义在类结构中的另一个类</div><div>类中定义的成员：</div><div>    字段：</div><div>    方法：</div><div>    内部类：</div><hr/><div>为什么使用内部类：</div><div>1、增强封装，把内部类隐藏在外部类之内，不许其他类访问该类</div><div>2、内部类能提高代码的可读性和可维护性，把小类型嵌入到外部类中节藕上代码更靠近</div><div>3、内部类可以直接访问外部类的成员</div><hr/><div>内部类根据使用不同的修饰符或者定义的位置不同，分成四种</div><div>四种内部类：</div><div>1、实例内部类：内部类没有使用static修饰</div><div>2、静态内部类：内部类使用了static修饰</div><div>3、局部内部类：在方法中定义的内部类</div><div>4、<span style="color: rgb(4, 51, 255);">匿名内部类使用于仅使用一次的类，属于局部内部类的特殊情况</span></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>面向接口编程思想</h1><div  /></td></tr></tbody></table><div>面向接口编程：多态的好处：把实现类对象赋给接口类型，屏蔽了不同实现类之间的实现差异，从而可以做到通用编程</div><div><br/></div><div>案例：使用USB设备工作</div><hr/><div>//制定USB规范</div><div>interface IUSB</div><div>{</div><div>    void swapData();</div><div>}</div><div><br/></div><div>//鼠标</div><div>class Mouse implements IUSB</div><div>{</div><div>    public void swapData()</div><div>    {</div><div>        System.out.println("鼠标在移动");</div><div>    }</div><div>}</div><div>//主板</div><div>class MotherBord</div><div>{</div><div>    private static IUSB[] usbs=new IUSB[6];</div><div>    private static int index=0;//插入到第几个位置</div><div>    //把设备插入主板的功能,接收usb类型的对象</div><div>    public static void pluginIn(IUSB usb)</div><div>    {</div><div>        if(index==usbs.length)</div><div>        {</div><div>            System.out.println("USB插槽插满了");</div><div>            return;</div><div>        }</div><div>        System.out.println("安装usb设备");</div><div>        usbs[index]=usb;</div><div>        index++;</div><div>    }</div><div>    //取出主板中的每一个usb设备并工作</div><div>    public static void doWork()</div><div>    {</div><div>        for(IUSB usb:usbs)</div><div>        {</div><div>            if(usb!=null){</div><div>                usb.swapData();</div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div>//打印机</div><div>class Print implements IUSB</div><div>{</div><div>    public void swapData()</div><div>    {</div><div>        System.out.println("打印");</div><div>    }</div><div>}</div><div>/*</div><div>    面向接口编程：多态的好处：把实现类对象赋给接口类型，屏蔽了不同实现类直线的实现差异，从而可以做到通用编程</div><div><br/></div><div>    案例：使用USB设备工作</div><div>*/</div><div>public class USBDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //创建鼠标对象</div><div>        Mouse m=new Mouse();</div><div>        MotherBord.pluginIn(m);</div><div>        //创建打印机对象</div><div>        Print p=new Print();</div><div>        MotherBord.pluginIn(p);</div><div>        //安装打印机</div><div>        MotherBord.pluginIn(new Print());</div><div>        </div><div>        //调用主板的工作行为</div><div>        MotherBord.doWork();</div><div>    }</div><div>}</div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>接口和抽象类的区别</h1><div  /></td></tr></tbody></table><div>接口和抽象类的区别：</div><div><span style="color: rgb(255, 38, 0);">相同点：</span></div><div>1、都位于继承的顶端，用于被其他实现或继承</div><div>2、都不能实例化</div><div>3、都可以定义抽象方法，其子类／实现类必须覆写这些方法</div><div><span style="color: rgb(255, 38, 0);">不同点：</span></div><div>1、<span style="color: rgb(4, 51, 255);">接口没有构造方法，抽象类有构造方法</span></div><div>2、抽象类可包含普通方法和抽象方法，接口只能包含抽象方法（java8之前）</div><div>3、一个类只能继承一个直接父类（可能是抽象类），接口是多继承的，并且支持一个类多实现接口（<span style="color: rgb(4, 51, 255);">接口弥补了java的单继承</span>）</div><div>4、成员变量：接口里默认的是public static final，抽象类是默认包权限</div><div>5、方法：接口里默认的是public abstract，抽象类默认是包权限</div><div>6、内部类：接口里默认的是public static，抽象类默认是包权限</div><hr/><div>如果接口和实现类可以完成相同的功能，尽量使用接口，面向接口编程</div><div>设计模式：接口和抽象类结合使用（适配器模式）</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>接口的实现关系</h1><div  /></td></tr></tbody></table><div>接口必须有实现类才有意义</div><div>接口的实现者：实现类</div><div>    接口仅仅只是定义了某一类食物应该具有某些功能，但是没有提供任何实现</div><div>   <span style="color: rgb(4, 51, 255);"> 此时我们得提供类，再让该类去实现接口，并覆盖接口中的方法，从而实现了接口中定义的功能</span></div><hr/><div><span style="color: rgb(4, 51, 255);">接口的实现类之间的关系，严格上称为“实现关系”，使用implements</span></div><div><span style="color: rgb(4, 51, 255);">但是在开发中有时候为了方便也把这个实现关系称为特殊的继承关系</span></div><div><span style="color: rgb(4, 51, 255);">    </span><span style="color: rgb(4, 51, 255);">    所以可以这样理解：接口是实现类的父类，实现类就是接口的子类</span></div><div><span style="color: rgb(4, 51, 255);">面向接口编程：</span></div><div><span style="color: rgb(4, 51, 255);">        </span><span style="color: rgb(255, 38, 0);">接口   变量= 创建实现类对象;//体现了多态思想</span></div><div><span style="color: rgb(4, 51, 255);">    </span><span style="color: rgb(4, 51, 255);">    接口和实现类的多态关系才是见的最多的</span></div><hr style="color: rgb(4, 51, 255);"/><div>类实现接口的语法：一个类可以实现多个接口，也弥补了类的单继承问题</div><div>[修饰符] class 实现类类名 implements 接口1，接口2</div><div><br/></div><div>因为：接口中的方法是公共的抽象的，所以实现类必须覆盖接口中的方法，并且方法必须使用public修饰</div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>接口的特点和接口的继承</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079902,103.851635">Map</a></div><div  /></td></tr></tbody></table><div>接口的特点：</div><div>1、没有构造方法，不能实例化，也不能显示定义构造器</div><div>2、接口只能继承接口，不能继承类，且接口支持多继承</div><div>    [修饰符] interface 接口名 extends 接口1，接口2</div><div>3、接口里的方法全是抽象的，默认修饰符是public abstract</div><div>4、接口里的字段全是全局静态常量，默认修饰符是public static final</div><div>5、接口里的内部类全是公共静态的，默认修饰符是public static</div><hr/><div>类和类之间存在继承关系：使用extends来表示</div><div>接口和接口之间只能是继承关系：使用extends来表示</div><div>接口和实现类之间只能是实现关系（继承关系）：使用implements来表示</div><hr/><div>//爬行动物规范</div><div>interface IWalkable</div><div>{</div><div>    void walk();</div><div>}</div><div>//水生动物规范</div><div>interface ISwimable</div><div>{</div><div>    void swim();</div><div>}</div><div>//两栖动物规范</div><div>interface Amphibiousable extends IWalkable,ISwimable</div><div>{</div><div>    </div><div>}</div><div>//猫</div><div>class Cat implements IWalkable</div><div>{</div><div>    public void walk()</div><div>    {</div><div>        System.out.println("猫");</div><div>    }</div><div>}</div><div>//鱼</div><div>class Fish implements ISwimable</div><div>{</div><div>    public void swim(){</div><div>        System.out.println("鱼");</div><div>    }</div><div>}</div><div>//青蛙</div><div>class Frog extends Animal implements IWalkable,ISwimable</div><div>{</div><div>    public void walk()</div><div>    {</div><div>        System.out.println("青蛙走");</div><div>    }</div><div>    public void swim()</div><div>    {</div><div>        System.out.println("青蛙游");</div><div>    }</div><div>}</div><div>//演示接口</div><div>public class InterfaceDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div>        //Cat c=new Cat();</div><div>        IWalkable c=new Cat();//面向接口编程存在多态</div><div>        c.walk();//体现多态特征，执行Cat类中的Walk方法</div><div><br/></div><div>        ISwimable f=new Fish();</div><div>        f.swim();</div><div><br/></div><div>        Frog f=new Frog();</div><div>        f.walk();</div><div>        f.swim()</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>接口的定义和接口的成员</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.079924,103.851697">Map</a></div><div  /></td></tr></tbody></table><div>Java中的接口：</div><div>    多个抽象类的抽象就是接口</div><div>    在java中，最小的程序单元就是类，java中的接口时一个特殊的类</div><div>    java中的接口表示规范，用于定义一组抽象方法，表示某一类食物必需具备的功能，要求实现类必须来实现其功能</div><hr/><div>定义类语法：[public] class 类名{}</div><div>定义接口语法：[public] interface 接口名{}，在这里还没有考虑接口的父接口等</div><div>    接口起名问题：具有某些能力的，有些人习惯以able／handler结尾</div><div>                             有的公司和个人习惯以I打头来表示接口，用于表示接口    </div><div>    接口在成功编译之后，和类一样，具有一份字节码</div><hr/><div>接口存在的成员：</div><div>    1、接口中没有构造器，推论：接口不能创建对象（不能new），接口中不能定义普通方法</div><div>    2、接口中定义的成员变量，实质上是全局静态常量</div><div>    3、接口中定义的方法都是公共的抽象方法，默认使用public abstract来修饰方法</div><div>        public abstract void walk();一般的我们在接口中定义方法，不使用修饰符</div><div>    4、接口中定义的内部类都是公共的静态内部类，默认使用public static来修饰内部类</div><div>            public static interface ABC{}</div><hr/><div>标志接口：接口中没有任何成员，就仅仅是一个接口的定义，就是一个标志，其他的类实现该接口就属于该家族，我们可以第三方程序赋予该接口实现类特殊的功能（不推荐）</div><div>常量接口：有人喜欢使用接口来封装多个常量信息，我们就称为常量接口，其目的和常量类相同，我们不推荐这种方式</div><hr/><div>//定义一个接口</div><div>interface IWalkable</div><div>{</div><div>    String NAME="1";</div><div><br/></div><div>    void walk();</div><div><br/></div><div>    class ABC</div><div>    {</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><div>//演示接口</div><div>public class InterfaceDemo</div><div>{</div><div>    public static void main(String[] args)</div><div>    {</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><tbody><tr><td><div    /><h1>什么是接口和为什么需要接口</h1><div>    <a style="font-weight: bold;" href="http://maps.google.com/maps?z=6&amp;q=36.080035,103.851919">Map</a></div><div  /></td></tr></tbody></table><div><span style="font-weight: bold;">什么是接口：</span></div><div>    硬件接口：指的是<span style="color: rgb(4, 51, 255);">两个硬件设备之间的连接方式</span>，硬件接口及包括物理上的接口，还包括<span style="color: rgb(4, 51, 255);">逻辑上的数据传输协议</span></div><div>    软件接口：程序代码，特殊的类，表示一种规格，<span style="color: rgb(255, 38, 0);">是具有的N个方法的特征集合</span></div><hr/><div>    在封装时，显示器封装了很多电子元件，最终向外暴露数据交互的孔—&gt;接口</div><div>    目的：设备和设备之间通信桥梁</div><div>在java中，接口表示一种规范／约束／要求实现着必须遵循该规则：用来约束使用者应该怎么做</div><hr/><div>接口知识定义了类应当遵循的规范，却不关心这些类的内部数据和其功能的实现细节，站在程序角度上说接口只规定了类里必须提供的方法，从而分离了规范和实现，增强了系统的可拓展性和可维护性</div><hr/><div>面向接口编程：</div><div>    接口和实现类体现了真正的多态的思想</div><div><br/></div><div><br/></div></body></html>